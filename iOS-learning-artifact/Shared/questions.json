[
    
    {
        "questionId": "1",
        "questionFrontendId": "1",
        "questionTitle": "Two Sum",
        "translatedTitle": "两数之和",
        "questionTitleSlug": "two-sum",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"1.5M\", \"totalSubmission\": \"3M\", \"totalAcceptedRaw\": 1476743, \"totalSubmissionRaw\": 2970468, \"acRate\": \"49.7%\"}",
        "translatedContent": "<p>给定一个整数数组 <code>nums</code>&nbsp;和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那&nbsp;<strong>两个</strong>&nbsp;整数，并返回他们的数组下标。</p>\n\n<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[<strong>0</strong>] + nums[<strong>1</strong>] = 2 + 7 = 9\n所以返回 [<strong>0, 1</strong>]\n</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Hash Table",
                "slug": "hash-table"
            }
        ]
    },
    {
        "questionId": "2",
        "questionFrontendId": "2",
        "questionTitle": "Add Two Numbers",
        "translatedTitle": "两数相加",
        "questionTitleSlug": "add-two-numbers",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"598.9K\", \"totalSubmission\": \"1.5M\", \"totalAcceptedRaw\": 598943, \"totalSubmissionRaw\": 1545991, \"acRate\": \"38.7%\"}",
        "translatedContent": "<p>给出两个&nbsp;<strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照&nbsp;<strong>逆序</strong>&nbsp;的方式存储的，并且它们的每个节点只能存储&nbsp;<strong>一位</strong>&nbsp;数字。</p>\n\n<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>\n\n<p>您可以假设除了数字 0 之外，这两个数都不会以 0&nbsp;开头。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)\n<strong>输出：</strong>7 -&gt; 0 -&gt; 8\n<strong>原因：</strong>342 + 465 = 807\n</pre>\n",
        "topicTags": [
            {
                "name": "Linked List",
                "slug": "linked-list"
            },
            {
                "name": "Math",
                "slug": "math"
            }
        ]
    },
    {
        "questionId": "3",
        "questionFrontendId": "3",
        "questionTitle": "Longest Substring Without Repeating Characters",
        "translatedTitle": "无重复字符的最长子串",
        "questionTitleSlug": "longest-substring-without-repeating-characters",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"698K\", \"totalSubmission\": \"2M\", \"totalAcceptedRaw\": 698049, \"totalSubmissionRaw\": 1951535, \"acRate\": \"35.8%\"}",
        "translatedContent": "<p>给定一个字符串，请你找出其中不含有重复字符的&nbsp;<strong>最长子串&nbsp;</strong>的长度。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入: </strong>&quot;abcabcbb&quot;\n<strong>输出: </strong>3 \n<strong>解释:</strong> 因为无重复字符的最长子串是 <code>&quot;abc&quot;，所以其</code>长度为 3。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入: </strong>&quot;bbbbb&quot;\n<strong>输出: </strong>1\n<strong>解释: </strong>因为无重复字符的最长子串是 <code>&quot;b&quot;</code>，所以其长度为 1。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre><strong>输入: </strong>&quot;pwwkew&quot;\n<strong>输出: </strong>3\n<strong>解释: </strong>因为无重复字符的最长子串是&nbsp;<code>&quot;wke&quot;</code>，所以其长度为 3。\n&nbsp;    请注意，你的答案必须是 <strong>子串 </strong>的长度，<code>&quot;pwke&quot;</code>&nbsp;是一个<em>子序列，</em>不是子串。\n</pre>\n",
        "topicTags": [
            {
                "name": "Hash Table",
                "slug": "hash-table"
            },
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            },
            {
                "name": "String",
                "slug": "string"
            },
            {
                "name": "Sliding Window",
                "slug": "sliding-window"
            }
        ]
    },
    {
        "questionId": "4",
        "questionFrontendId": "4",
        "questionTitle": "Median of Two Sorted Arrays",
        "translatedTitle": "寻找两个正序数组的中位数",
        "questionTitleSlug": "median-of-two-sorted-arrays",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"275.3K\", \"totalSubmission\": \"707.8K\", \"totalAcceptedRaw\": 275309, \"totalSubmissionRaw\": 707758, \"acRate\": \"38.9%\"}",
        "translatedContent": "<p>给定两个大小为 m 和 n 的正序（从小到大）数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>。请你找出并返回这两个正序数组的中位数。</p>\n\n<p><strong>进阶：</strong>你能设计一个时间复杂度为 <code>O(log (m+n))</code> 的算法解决此问题吗？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [1,3], nums2 = [2]\n<strong>输出：</strong>2.00000\n<strong>解释：</strong>合并数组 = [1,2,3] ，中位数 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [1,2], nums2 = [3,4]\n<strong>输出：</strong>2.50000\n<strong>解释：</strong>合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [0,0], nums2 = [0,0]\n<strong>输出：</strong>0.00000\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [], nums2 = [1]\n<strong>输出：</strong>1.00000\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [2], nums2 = []\n<strong>输出：</strong>2.00000\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums1.length == m</code></li>\n\t<li><code>nums2.length == n</code></li>\n\t<li><code>0 &lt;= m &lt;= 1000</code></li>\n\t<li><code>0 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= m + n &lt;= 2000</code></li>\n\t<li><code>-10<sup>6</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Binary Search",
                "slug": "binary-search"
            },
            {
                "name": "Divide and Conquer",
                "slug": "divide-and-conquer"
            }
        ]
    },
    {
        "questionId": "5",
        "questionFrontendId": "5",
        "questionTitle": "Longest Palindromic Substring",
        "translatedTitle": "最长回文子串",
        "questionTitleSlug": "longest-palindromic-substring",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"401.1K\", \"totalSubmission\": \"1.2M\", \"totalAcceptedRaw\": 401053, \"totalSubmissionRaw\": 1248181, \"acRate\": \"32.1%\"}",
        "translatedContent": "<p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设&nbsp;<code>s</code> 的最大长度为 1000。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入:</strong> &quot;babad&quot;\n<strong>输出:</strong> &quot;bab&quot;\n<strong>注意:</strong> &quot;aba&quot; 也是一个有效答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入:</strong> &quot;cbbd&quot;\n<strong>输出:</strong> &quot;bb&quot;\n</pre>\n",
        "topicTags": [
            {
                "name": "String",
                "slug": "string"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "6",
        "questionFrontendId": "6",
        "questionTitle": "ZigZag Conversion",
        "translatedTitle": "Z 字形变换",
        "questionTitleSlug": "zigzag-conversion",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"181.6K\", \"totalSubmission\": \"371.1K\", \"totalAcceptedRaw\": 181580, \"totalSubmissionRaw\": 371136, \"acRate\": \"48.9%\"}",
        "translatedContent": "<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行&nbsp;Z 字形排列。</p>\n\n<p>比如输入字符串为 <code>&quot;LEETCODEISHIRING&quot;</code>&nbsp;行数为 3 时，排列如下：</p>\n\n<pre>L   C   I   R\nE T O E S I I G\nE   D   H   N\n</pre>\n\n<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。</p>\n\n<p>请你实现这个将字符串进行指定行数变换的函数：</p>\n\n<pre>string convert(string s, int numRows);</pre>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> s = &quot;LEETCODEISHIRING&quot;, numRows = 3\n<strong>输出:</strong> &quot;LCIRETOESIIGEDHN&quot;\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> s = &quot;LEETCODEISHIRING&quot;, numRows =&nbsp;4\n<strong>输出:</strong>&nbsp;&quot;LDREOEIIECIHNTSG&quot;\n<strong>解释:</strong>\n\nL     D     R\nE   O E   I I\nE C   I H   N\nT     S     G</pre>\n",
        "topicTags": [
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "7",
        "questionFrontendId": "7",
        "questionTitle": "Reverse Integer",
        "translatedTitle": "整数反转",
        "questionTitleSlug": "reverse-integer",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"491.3K\", \"totalSubmission\": \"1.4M\", \"totalAcceptedRaw\": 491287, \"totalSubmissionRaw\": 1415599, \"acRate\": \"34.7%\"}",
        "translatedContent": "<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> 123\n<strong>输出:</strong> 321\n</pre>\n\n<p><strong>&nbsp;示例 2:</strong></p>\n\n<pre><strong>输入:</strong> -123\n<strong>输出:</strong> -321\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre><strong>输入:</strong> 120\n<strong>输出:</strong> 21\n</pre>\n\n<p><strong>注意:</strong></p>\n\n<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为&nbsp;[&minus;2<sup>31</sup>,&nbsp; 2<sup>31&nbsp;</sup>&minus; 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>\n",
        "topicTags": [
            {
                "name": "Math",
                "slug": "math"
            }
        ]
    },
    {
        "questionId": "8",
        "questionFrontendId": "8",
        "questionTitle": "String to Integer (atoi)",
        "translatedTitle": "字符串转换整数 (atoi)",
        "questionTitleSlug": "string-to-integer-atoi",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"217.1K\", \"totalSubmission\": \"1M\", \"totalAcceptedRaw\": 217137, \"totalSubmissionRaw\": 1033271, \"acRate\": \"21.0%\"}",
        "translatedContent": "<p>请你来实现一个&nbsp;<code>atoi</code>&nbsp;函数，使其能将字符串转换成整数。</p>\n\n<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p>\n\n<ul>\n\t<li>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。</li>\n\t<li>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。</li>\n\t<li>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。</li>\n</ul>\n\n<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p>\n\n<p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>本题中的空白字符只包括空格字符 <code>&#39; &#39;</code> 。</li>\n\t<li>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为&nbsp;[&minus;2<sup>31</sup>,&nbsp; 2<sup>31&nbsp;</sup>&minus; 1]。如果数值超过这个范围，请返回 &nbsp;INT_MAX (2<sup>31&nbsp;</sup>&minus; 1) 或&nbsp;INT_MIN (&minus;2<sup>31</sup>) 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> &quot;42&quot;\n<strong>输出:</strong> 42\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> &quot;   -42&quot;\n<strong>输出:</strong> -42\n<strong>解释: </strong>第一个非空白字符为 &#39;-&#39;, 它是一个负号。\n&nbsp;    我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre><strong>输入:</strong> &quot;4193 with words&quot;\n<strong>输出:</strong> 4193\n<strong>解释:</strong> 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。\n</pre>\n\n<p><strong>示例&nbsp;4:</strong></p>\n\n<pre><strong>输入:</strong> &quot;words and 987&quot;\n<strong>输出:</strong> 0\n<strong>解释:</strong> 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。\n     因此无法执行有效的转换。</pre>\n\n<p><strong>示例&nbsp;5:</strong></p>\n\n<pre><strong>输入:</strong> &quot;-91283472332&quot;\n<strong>输出:</strong> -2147483648\n<strong>解释:</strong> 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 \n&nbsp;    因此返回 INT_MIN (&minus;2<sup>31</sup>) 。\n</pre>\n",
        "topicTags": [
            {
                "name": "Math",
                "slug": "math"
            },
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "9",
        "questionFrontendId": "9",
        "questionTitle": "Palindrome Number",
        "translatedTitle": "回文数",
        "questionTitleSlug": "palindrome-number",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"474.6K\", \"totalSubmission\": \"811.5K\", \"totalAcceptedRaw\": 474591, \"totalSubmissionRaw\": 811456, \"acRate\": \"58.5%\"}",
        "translatedContent": "<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> 121\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> -121\n<strong>输出:</strong> false\n<strong>解释:</strong> 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre><strong>输入:</strong> 10\n<strong>输出:</strong> false\n<strong>解释:</strong> 从右向左读, 为 01 。因此它不是一个回文数。\n</pre>\n\n<p><strong>进阶:</strong></p>\n\n<p>你能不将整数转为字符串来解决这个问题吗？</p>\n",
        "topicTags": [
            {
                "name": "Math",
                "slug": "math"
            }
        ]
    },
    {
        "questionId": "10",
        "questionFrontendId": "10",
        "questionTitle": "Regular Expression Matching",
        "translatedTitle": "正则表达式匹配",
        "questionTitleSlug": "regular-expression-matching",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"121.9K\", \"totalSubmission\": \"401.3K\", \"totalAcceptedRaw\": 121896, \"totalSubmissionRaw\": 401338, \"acRate\": \"30.4%\"}",
        "translatedContent": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;和一个字符规律&nbsp;<code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code>&nbsp;和&nbsp;<code>&#39;*&#39;</code>&nbsp;的正则表达式匹配。</p>\n\n<pre>&#39;.&#39; 匹配任意单个字符\n&#39;*&#39; 匹配零个或多个前面的那一个元素\n</pre>\n\n<p>所谓匹配，是要涵盖&nbsp;<strong>整个&nbsp;</strong>字符串&nbsp;<code>s</code>的，而不是部分字符串。</p>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li><code>s</code>&nbsp;可能为空，且只包含从&nbsp;<code>a-z</code>&nbsp;的小写字母。</li>\n\t<li><code>p</code>&nbsp;可能为空，且只包含从&nbsp;<code>a-z</code>&nbsp;的小写字母，以及字符&nbsp;<code>.</code>&nbsp;和&nbsp;<code>*</code>。</li>\n</ul>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong>\ns = &quot;aa&quot;\np = &quot;a&quot;\n<strong>输出:</strong> false\n<strong>解释:</strong> &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong>\ns = &quot;aa&quot;\np = &quot;a*&quot;\n<strong>输出:</strong> true\n<strong>解释:</strong>&nbsp;因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre><strong>输入:</strong>\ns = &quot;ab&quot;\np = &quot;.*&quot;\n<strong>输出:</strong> true\n<strong>解释:</strong>&nbsp;&quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。\n</pre>\n\n<p><strong>示例 4:</strong></p>\n\n<pre><strong>输入:</strong>\ns = &quot;aab&quot;\np = &quot;c*a*b&quot;\n<strong>输出:</strong> true\n<strong>解释:</strong>&nbsp;因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。\n</pre>\n\n<p><strong>示例 5:</strong></p>\n\n<pre><strong>输入:</strong>\ns = &quot;mississippi&quot;\np = &quot;mis*is*p*.&quot;\n<strong>输出:</strong> false</pre>\n",
        "topicTags": [
            {
                "name": "String",
                "slug": "string"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            },
            {
                "name": "Backtracking",
                "slug": "backtracking"
            }
        ]
    },
    {
        "questionId": "11",
        "questionFrontendId": "11",
        "questionTitle": "Container With Most Water",
        "translatedTitle": "盛最多水的容器",
        "questionTitleSlug": "container-with-most-water",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"303.2K\", \"totalSubmission\": \"471.5K\", \"totalAcceptedRaw\": 303152, \"totalSubmissionRaw\": 471502, \"acRate\": \"64.3%\"}",
        "translatedContent": "<p>给你 <em>n</em> 个非负整数 <em>a</em><sub>1</sub>，<em>a</em><sub>2，</sub>...，<em>a</em><sub>n，</sub>每个数代表坐标中的一个点&nbsp;(<em>i</em>,&nbsp;<em>a<sub>i</sub></em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em>&nbsp;的两个端点分别为&nbsp;(<em>i</em>,&nbsp;<em>a<sub>i</sub></em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与&nbsp;<em>x</em>&nbsp;轴共同构成的容器可以容纳最多的水。</p>\n\n<p><strong>说明：</strong>你不能倾斜容器，且&nbsp;<em>n</em>&nbsp;的值至少为 2。</p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg\" style=\"height: 287px; width: 600px;\"></p>\n\n<p><small>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为&nbsp;49。</small></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>[1,8,6,2,5,4,8,3,7]\n<strong>输出：</strong>49</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            }
        ]
    },
    {
        "questionId": "12",
        "questionFrontendId": "12",
        "questionTitle": "Integer to Roman",
        "translatedTitle": "整数转罗马数字",
        "questionTitleSlug": "integer-to-roman",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"121.5K\", \"totalSubmission\": \"188.5K\", \"totalAcceptedRaw\": 121533, \"totalSubmissionRaw\": 188502, \"acRate\": \"64.5%\"}",
        "translatedContent": "<p>罗马数字包含以下七种字符：&nbsp;<code>I</code>，&nbsp;<code>V</code>，&nbsp;<code>X</code>，&nbsp;<code>L</code>，<code>C</code>，<code>D</code>&nbsp;和&nbsp;<code>M</code>。</p>\n\n<pre><strong>字符</strong>          <strong>数值</strong>\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000</pre>\n\n<p>例如， 罗马数字 2 写做&nbsp;<code>II</code>&nbsp;，即为两个并列的 1。12 写做&nbsp;<code>XII</code>&nbsp;，即为&nbsp;<code>X</code>&nbsp;+&nbsp;<code>II</code>&nbsp;。 27 写做&nbsp;&nbsp;<code>XXVII</code>, 即为&nbsp;<code>XX</code>&nbsp;+&nbsp;<code>V</code>&nbsp;+&nbsp;<code>II</code>&nbsp;。</p>\n\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做&nbsp;<code>IIII</code>，而是&nbsp;<code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为&nbsp;<code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>\n\n<ul>\n\t<li><code>I</code>&nbsp;可以放在&nbsp;<code>V</code>&nbsp;(5) 和&nbsp;<code>X</code>&nbsp;(10) 的左边，来表示 4 和 9。</li>\n\t<li><code>X</code>&nbsp;可以放在&nbsp;<code>L</code>&nbsp;(50) 和&nbsp;<code>C</code>&nbsp;(100) 的左边，来表示 40 和&nbsp;90。&nbsp;</li>\n\t<li><code>C</code>&nbsp;可以放在&nbsp;<code>D</code>&nbsp;(500) 和&nbsp;<code>M</code>&nbsp;(1000) 的左边，来表示&nbsp;400 和&nbsp;900。</li>\n</ul>\n\n<p>给定一个整数，将其转为罗马数字。输入确保在 1&nbsp;到 3999 的范围内。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong>&nbsp;3\n<strong>输出:</strong> &quot;III&quot;</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong>&nbsp;4\n<strong>输出:</strong> &quot;IV&quot;</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre><strong>输入:</strong>&nbsp;9\n<strong>输出:</strong> &quot;IX&quot;</pre>\n\n<p><strong>示例&nbsp;4:</strong></p>\n\n<pre><strong>输入:</strong>&nbsp;58\n<strong>输出:</strong> &quot;LVIII&quot;\n<strong>解释:</strong> L = 50, V = 5, III = 3.\n</pre>\n\n<p><strong>示例&nbsp;5:</strong></p>\n\n<pre><strong>输入:</strong>&nbsp;1994\n<strong>输出:</strong> &quot;MCMXCIV&quot;\n<strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</pre>\n",
        "topicTags": [
            {
                "name": "Math",
                "slug": "math"
            },
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "13",
        "questionFrontendId": "13",
        "questionTitle": "Roman to Integer",
        "translatedTitle": "罗马数字转整数",
        "questionTitleSlug": "roman-to-integer",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"270.6K\", \"totalSubmission\": \"435.7K\", \"totalAcceptedRaw\": 270615, \"totalSubmissionRaw\": 435745, \"acRate\": \"62.1%\"}",
        "translatedContent": "<p>罗马数字包含以下七种字符:&nbsp;<code>I</code>，&nbsp;<code>V</code>，&nbsp;<code>X</code>，&nbsp;<code>L</code>，<code>C</code>，<code>D</code>&nbsp;和&nbsp;<code>M</code>。</p>\n\n<pre><strong>字符</strong>          <strong>数值</strong>\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000</pre>\n\n<p>例如， 罗马数字 2 写做&nbsp;<code>II</code>&nbsp;，即为两个并列的 1。12 写做&nbsp;<code>XII</code>&nbsp;，即为&nbsp;<code>X</code>&nbsp;+&nbsp;<code>II</code>&nbsp;。 27 写做&nbsp;&nbsp;<code>XXVII</code>, 即为&nbsp;<code>XX</code>&nbsp;+&nbsp;<code>V</code>&nbsp;+&nbsp;<code>II</code>&nbsp;。</p>\n\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做&nbsp;<code>IIII</code>，而是&nbsp;<code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为&nbsp;<code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>\n\n<ul>\n\t<li><code>I</code>&nbsp;可以放在&nbsp;<code>V</code>&nbsp;(5) 和&nbsp;<code>X</code>&nbsp;(10) 的左边，来表示 4 和 9。</li>\n\t<li><code>X</code>&nbsp;可以放在&nbsp;<code>L</code>&nbsp;(50) 和&nbsp;<code>C</code>&nbsp;(100) 的左边，来表示 40 和&nbsp;90。&nbsp;</li>\n\t<li><code>C</code>&nbsp;可以放在&nbsp;<code>D</code>&nbsp;(500) 和&nbsp;<code>M</code>&nbsp;(1000) 的左边，来表示&nbsp;400 和&nbsp;900。</li>\n</ul>\n\n<p>给定一个罗马数字，将其转换成整数。输入确保在 1&nbsp;到 3999 的范围内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong>&nbsp;&quot;III&quot;\n<strong>输出:</strong> 3</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong>&nbsp;&quot;IV&quot;\n<strong>输出:</strong> 4</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre><strong>输入:</strong>&nbsp;&quot;IX&quot;\n<strong>输出:</strong> 9</pre>\n\n<p><strong>示例&nbsp;4:</strong></p>\n\n<pre><strong>输入:</strong>&nbsp;&quot;LVIII&quot;\n<strong>输出:</strong> 58\n<strong>解释:</strong> L = 50, V= 5, III = 3.\n</pre>\n\n<p><strong>示例&nbsp;5:</strong></p>\n\n<pre><strong>输入:</strong>&nbsp;&quot;MCMXCIV&quot;\n<strong>输出:</strong> 1994\n<strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li>\n\t<li>IC 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li>\n\t<li>关于罗马数字的详尽书写规则，可以参考 <a href=\"https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97#knowledge_article\">罗马数字 - Mathematics </a>。</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Math",
                "slug": "math"
            },
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "14",
        "questionFrontendId": "14",
        "questionTitle": "Longest Common Prefix",
        "translatedTitle": "最长公共前缀",
        "questionTitleSlug": "longest-common-prefix",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"381.5K\", \"totalSubmission\": \"981.8K\", \"totalAcceptedRaw\": 381516, \"totalSubmissionRaw\": 981813, \"acRate\": \"38.9%\"}",
        "translatedContent": "<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>\n\n<p>如果不存在公共前缀，返回空字符串&nbsp;<code>&quot;&quot;</code>。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入: </strong>[&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]\n<strong>输出:</strong> &quot;fl&quot;\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入: </strong>[&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]\n<strong>输出:</strong> &quot;&quot;\n<strong>解释:</strong> 输入不存在公共前缀。\n</pre>\n\n<p><strong>说明:</strong></p>\n\n<p>所有输入只包含小写字母&nbsp;<code>a-z</code>&nbsp;。</p>\n",
        "topicTags": [
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "15",
        "questionFrontendId": "15",
        "questionTitle": "3Sum",
        "translatedTitle": "三数之和",
        "questionTitleSlug": "3sum",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"348.8K\", \"totalSubmission\": \"1.2M\", \"totalAcceptedRaw\": 348832, \"totalSubmissionRaw\": 1169385, \"acRate\": \"29.8%\"}",
        "translatedContent": "<p>给你一个包含 <em>n</em> 个整数的数组&nbsp;<code>nums</code>，判断&nbsp;<code>nums</code>&nbsp;中是否存在三个元素 <em>a，b，c ，</em>使得&nbsp;<em>a + b + c = </em>0 ？请你找出所有满足条件且不重复的三元组。</p>\n\n<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n\n满足要求的三元组集合为：\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            }
        ]
    },
    {
        "questionId": "16",
        "questionFrontendId": "16",
        "questionTitle": "3Sum Closest",
        "translatedTitle": "最接近的三数之和",
        "questionTitleSlug": "3sum-closest",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"161.4K\", \"totalSubmission\": \"351.9K\", \"totalAcceptedRaw\": 161419, \"totalSubmissionRaw\": 351930, \"acRate\": \"45.9%\"}",
        "translatedContent": "<p>给定一个包括&nbsp;<em>n</em> 个整数的数组&nbsp;<code>nums</code><em>&nbsp;</em>和 一个目标值&nbsp;<code>target</code>。找出&nbsp;<code>nums</code><em>&nbsp;</em>中的三个整数，使得它们的和与&nbsp;<code>target</code>&nbsp;最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>nums = [-1,2,1,-4], target = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 10^3</code></li>\n\t<li><code>-10^3&nbsp;&lt;= nums[i]&nbsp;&lt;= 10^3</code></li>\n\t<li><code>-10^4&nbsp;&lt;= target&nbsp;&lt;= 10^4</code></li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            }
        ]
    },
    {
        "questionId": "17",
        "questionFrontendId": "17",
        "questionTitle": "Letter Combinations of a Phone Number",
        "translatedTitle": "电话号码的字母组合",
        "questionTitleSlug": "letter-combinations-of-a-phone-number",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"186.3K\", \"totalSubmission\": \"335.8K\", \"totalAcceptedRaw\": 186329, \"totalSubmissionRaw\": 335808, \"acRate\": \"55.5%\"}",
        "translatedContent": "<p>给定一个仅包含数字&nbsp;<code>2-9</code>&nbsp;的字符串，返回所有它能表示的字母组合。</p>\n\n<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png\" style=\"width: 200px;\"></p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入：</strong>&quot;23&quot;\n<strong>输出：</strong>[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].\n</pre>\n\n<p><strong>说明:</strong><br>\n尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>\n",
        "topicTags": [
            {
                "name": "String",
                "slug": "string"
            },
            {
                "name": "Backtracking",
                "slug": "backtracking"
            }
        ]
    },
    {
        "questionId": "18",
        "questionFrontendId": "18",
        "questionTitle": "4Sum",
        "translatedTitle": "四数之和",
        "questionTitleSlug": "4sum",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"130.9K\", \"totalSubmission\": \"333.8K\", \"totalAcceptedRaw\": 130854, \"totalSubmissionRaw\": 333761, \"acRate\": \"39.2%\"}",
        "translatedContent": "<p>给定一个包含&nbsp;<em>n</em> 个整数的数组&nbsp;<code>nums</code>&nbsp;和一个目标值&nbsp;<code>target</code>，判断&nbsp;<code>nums</code>&nbsp;中是否存在四个元素 <em>a，</em><em>b，c</em>&nbsp;和 <em>d</em>&nbsp;，使得&nbsp;<em>a</em> + <em>b</em> + <em>c</em> + <em>d</em>&nbsp;的值与&nbsp;<code>target</code>&nbsp;相等？找出所有满足条件且不重复的四元组。</p>\n\n<p><strong>注意：</strong></p>\n\n<p>答案中不可以包含重复的四元组。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。\n\n满足要求的四元组集合为：\n[\n  [-1,  0, 0, 1],\n  [-2, -1, 1, 2],\n  [-2,  0, 0, 2]\n]\n</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Hash Table",
                "slug": "hash-table"
            },
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            }
        ]
    },
    {
        "questionId": "19",
        "questionFrontendId": "19",
        "questionTitle": "Remove Nth Node From End of List",
        "translatedTitle": "删除链表的倒数第N个节点",
        "questionTitleSlug": "remove-nth-node-from-end-of-list",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"270.5K\", \"totalSubmission\": \"669.6K\", \"totalAcceptedRaw\": 270480, \"totalSubmissionRaw\": 669586, \"acRate\": \"40.4%\"}",
        "translatedContent": "<p>给定一个链表，删除链表的倒数第&nbsp;<em>n&nbsp;</em>个节点，并且返回链表的头结点。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>给定一个链表: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, 和 <strong><em>n</em> = 2</strong>.\n\n当删除了倒数第二个节点后，链表变为 <strong>1-&gt;2-&gt;3-&gt;5</strong>.\n</pre>\n\n<p><strong>说明：</strong></p>\n\n<p>给定的 <em>n</em>&nbsp;保证是有效的。</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你能尝试使用一趟扫描实现吗？</p>\n",
        "topicTags": [
            {
                "name": "Linked List",
                "slug": "linked-list"
            },
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            }
        ]
    },
    {
        "questionId": "20",
        "questionFrontendId": "20",
        "questionTitle": "Valid Parentheses",
        "translatedTitle": "有效的括号",
        "questionTitleSlug": "valid-parentheses",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"437.2K\", \"totalSubmission\": \"1M\", \"totalAcceptedRaw\": 437187, \"totalSubmissionRaw\": 1013229, \"acRate\": \"43.1%\"}",
        "translatedContent": "<p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code>&nbsp;的字符串，判断字符串是否有效。</p>\n\n<p>有效字符串需满足：</p>\n\n<ol>\n\t<li>左括号必须用相同类型的右括号闭合。</li>\n\t<li>左括号必须以正确的顺序闭合。</li>\n</ol>\n\n<p>注意空字符串可被认为是有效字符串。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> &quot;()&quot;\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> &quot;()[]{}&quot;\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre><strong>输入:</strong> &quot;(]&quot;\n<strong>输出:</strong> false\n</pre>\n\n<p><strong>示例&nbsp;4:</strong></p>\n\n<pre><strong>输入:</strong> &quot;([)]&quot;\n<strong>输出:</strong> false\n</pre>\n\n<p><strong>示例&nbsp;5:</strong></p>\n\n<pre><strong>输入:</strong> &quot;{[]}&quot;\n<strong>输出:</strong> true</pre>\n",
        "topicTags": [
            {
                "name": "Stack",
                "slug": "stack"
            },
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "21",
        "questionFrontendId": "21",
        "questionTitle": "Merge Two Sorted Lists",
        "translatedTitle": "合并两个有序链表",
        "questionTitleSlug": "merge-two-sorted-lists",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"392.3K\", \"totalSubmission\": \"607.8K\", \"totalAcceptedRaw\": 392286, \"totalSubmissionRaw\": 607826, \"acRate\": \"64.5%\"}",
        "translatedContent": "<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>1-&gt;2-&gt;4, 1-&gt;3-&gt;4\n<strong>输出：</strong>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4\n</pre>\n",
        "topicTags": [
            {
                "name": "Linked List",
                "slug": "linked-list"
            }
        ]
    },
    {
        "questionId": "22",
        "questionFrontendId": "22",
        "questionTitle": "Generate Parentheses",
        "translatedTitle": "括号生成",
        "questionTitleSlug": "generate-parentheses",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"190.4K\", \"totalSubmission\": \"249.2K\", \"totalAcceptedRaw\": 190396, \"totalSubmissionRaw\": 249193, \"acRate\": \"76.4%\"}",
        "translatedContent": "<p>数字 <em>n</em>&nbsp;代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的 </strong>括号组合。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>n = 3\n<strong>输出：</strong>[\n       &quot;((()))&quot;,\n       &quot;(()())&quot;,\n       &quot;(())()&quot;,\n       &quot;()(())&quot;,\n       &quot;()()()&quot;\n     ]\n</pre>\n",
        "topicTags": [
            {
                "name": "String",
                "slug": "string"
            },
            {
                "name": "Backtracking",
                "slug": "backtracking"
            }
        ]
    },
    {
        "questionId": "23",
        "questionFrontendId": "23",
        "questionTitle": "Merge k Sorted Lists",
        "translatedTitle": "合并K个升序链表",
        "questionTitleSlug": "merge-k-sorted-lists",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"179.6K\", \"totalSubmission\": \"336.3K\", \"totalAcceptedRaw\": 179618, \"totalSubmissionRaw\": 336303, \"acRate\": \"53.4%\"}",
        "translatedContent": "<p>给你一个链表数组，每个链表都已经按升序排列。</p>\n\n<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>lists = [[1,4,5],[1,3,4],[2,6]]\n<strong>输出：</strong>[1,1,2,3,4,4,5,6]\n<strong>解释：</strong>链表数组如下：\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\n将它们合并到一个有序链表中得到。\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>lists = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>lists = [[]]\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>k == lists.length</code></li>\n\t<li><code>0 &lt;= k &lt;= 10^4</code></li>\n\t<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>\n\t<li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li>\n\t<li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li>\n\t<li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Heap",
                "slug": "heap"
            },
            {
                "name": "Linked List",
                "slug": "linked-list"
            },
            {
                "name": "Divide and Conquer",
                "slug": "divide-and-conquer"
            }
        ]
    },
    {
        "questionId": "24",
        "questionFrontendId": "24",
        "questionTitle": "Swap Nodes in Pairs",
        "translatedTitle": "两两交换链表中的节点",
        "questionTitleSlug": "swap-nodes-in-pairs",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"186.5K\", \"totalSubmission\": \"273.4K\", \"totalAcceptedRaw\": 186517, \"totalSubmissionRaw\": 273380, \"acRate\": \"68.2%\"}",
        "translatedContent": "<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>\n\n<p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg\" style=\"width: 422px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4]\n<strong>输出：</strong>[2,1,4,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>\n\t<li><code>0 <= Node.val <= 100</code></li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Linked List",
                "slug": "linked-list"
            }
        ]
    },
    {
        "questionId": "25",
        "questionFrontendId": "25",
        "questionTitle": "Reverse Nodes in k-Group",
        "translatedTitle": "K 个一组翻转链表",
        "questionTitleSlug": "reverse-nodes-in-k-group",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"109.5K\", \"totalSubmission\": \"172.8K\", \"totalAcceptedRaw\": 109481, \"totalSubmissionRaw\": 172752, \"acRate\": \"63.4%\"}",
        "translatedContent": "<p>给你一个链表，每&nbsp;<em>k&nbsp;</em>个节点一组进行翻转，请你返回翻转后的链表。</p>\n\n<p><em>k&nbsp;</em>是一个正整数，它的值小于或等于链表的长度。</p>\n\n<p>如果节点总数不是&nbsp;<em>k&nbsp;</em>的整数倍，那么请将最后剩余的节点保持原有顺序。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<p>给你这个链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>\n\n<p>当&nbsp;<em>k&nbsp;</em>= 2 时，应当返回: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>\n\n<p>当&nbsp;<em>k&nbsp;</em>= 3 时，应当返回: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>\n\n<p>&nbsp;</p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>你的算法只能使用常数的额外空间。</li>\n\t<li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Linked List",
                "slug": "linked-list"
            }
        ]
    },
    {
        "questionId": "26",
        "questionFrontendId": "26",
        "questionTitle": "Remove Duplicates from Sorted Array",
        "translatedTitle": "删除排序数组中的重复项",
        "questionTitleSlug": "remove-duplicates-from-sorted-array",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"447.7K\", \"totalSubmission\": \"861.3K\", \"totalAcceptedRaw\": 447710, \"totalSubmissionRaw\": 861259, \"acRate\": \"52.0%\"}",
        "translatedContent": "<p>给定一个排序数组，你需要在<strong><a href=\"http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\"> 原地</a></strong> 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>\n\n<p>不要使用额外的数组空间，你必须在 <strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\">原地 </a>修改输入数组 </strong>并在使用 O(1) 额外空间的条件下完成。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>给定数组 <em>nums</em> = <strong>[1,1,2]</strong>, \n\n函数应该返回新的长度 <strong>2</strong>, 并且原数组 <em>nums </em>的前两个元素被修改为 <strong><code>1</code></strong>, <strong><code>2</code></strong>。 \n\n你不需要考虑数组中超出新长度后面的元素。</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>给定<em> nums </em>= <strong>[0,0,1,1,1,2,2,3,3,4]</strong>,\n\n函数应该返回新的长度 <strong>5</strong>, 并且原数组 <em>nums </em>的前五个元素被修改为 <strong><code>0</code></strong>, <strong><code>1</code></strong>, <strong><code>2</code></strong>, <strong><code>3</code></strong>, <strong><code>4</code></strong>。\n\n你不需要考虑数组中超出新长度后面的元素。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>说明:</strong></p>\n\n<p>为什么返回数值是整数，但输出的答案是数组呢?</p>\n\n<p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>\n\n<p>你可以想象内部操作如下:</p>\n\n<pre>// <strong>nums</strong> 是以&ldquo;引用&rdquo;方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中<strong>该长度范围内</strong>的所有元素。\nfor (int i = 0; i &lt; len; i++) {\n&nbsp; &nbsp; print(nums[i]);\n}\n</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            }
        ]
    },
    {
        "questionId": "27",
        "questionFrontendId": "27",
        "questionTitle": "Remove Element",
        "translatedTitle": "移除元素",
        "questionTitleSlug": "remove-element",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"248K\", \"totalSubmission\": \"421.3K\", \"totalAcceptedRaw\": 248032, \"totalSubmissionRaw\": 421256, \"acRate\": \"58.9%\"}",
        "translatedContent": "<p>给你一个数组 <em>nums&nbsp;</em>和一个值 <em>val</em>，你需要 <strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\">原地</a></strong> 移除所有数值等于&nbsp;<em>val&nbsp;</em>的元素，并返回移除后数组的新长度。</p>\n\n<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 <strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\">原地 </a>修改输入数组</strong>。</p>\n\n<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>给定 <em>nums</em> = <strong>[3,2,2,3]</strong>, <em>val</em> = <strong>3</strong>,\n\n函数应该返回新的长度 <strong>2</strong>, 并且 <em>nums </em>中的前两个元素均为 <strong>2</strong>。\n\n你不需要考虑数组中超出新长度后面的元素。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>给定 <em>nums</em> = <strong>[0,1,2,2,3,0,4,2]</strong>, <em>val</em> = <strong>2</strong>,\n\n函数应该返回新的长度 <strong><code>5</code></strong>, 并且 <em>nums </em>中的前五个元素为 <strong><code>0</code></strong>, <strong><code>1</code></strong>, <strong><code>3</code></strong>, <strong><code>0</code></strong>, <strong>4</strong>。\n\n注意这五个元素可为任意顺序。\n\n你不需要考虑数组中超出新长度后面的元素。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>说明:</strong></p>\n\n<p>为什么返回数值是整数，但输出的答案是数组呢?</p>\n\n<p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>\n\n<p>你可以想象内部操作如下:</p>\n\n<pre>// <strong>nums</strong> 是以&ldquo;引用&rdquo;方式传递的。也就是说，不对实参作任何拷贝\nint len = removeElement(nums, val);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中<strong> 该长度范围内</strong> 的所有元素。\nfor (int i = 0; i &lt; len; i++) {\n&nbsp; &nbsp; print(nums[i]);\n}\n</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            }
        ]
    },
    {
        "questionId": "28",
        "questionFrontendId": "28",
        "questionTitle": "Implement strStr()",
        "translatedTitle": "实现 strStr()",
        "questionTitleSlug": "implement-strstr",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"246.5K\", \"totalSubmission\": \"621.8K\", \"totalAcceptedRaw\": 246544, \"totalSubmissionRaw\": 621841, \"acRate\": \"39.6%\"}",
        "translatedContent": "<p>实现&nbsp;<a href=\"https://baike.baidu.com/item/strstr/811469\" target=\"_blank\">strStr()</a>&nbsp;函数。</p>\n\n<p>给定一个&nbsp;haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回&nbsp; <strong>-1</strong>。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> haystack = &quot;hello&quot;, needle = &quot;ll&quot;\n<strong>输出:</strong> 2\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;\n<strong>输出:</strong> -1\n</pre>\n\n<p><strong>说明:</strong></p>\n\n<p>当&nbsp;<code>needle</code>&nbsp;是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>\n\n<p>对于本题而言，当&nbsp;<code>needle</code>&nbsp;是空字符串时我们应当返回 0 。这与C语言的&nbsp;<a href=\"https://baike.baidu.com/item/strstr/811469\" target=\"_blank\">strstr()</a>&nbsp;以及 Java的&nbsp;<a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)\" target=\"_blank\">indexOf()</a>&nbsp;定义相符。</p>\n",
        "topicTags": [
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            },
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "29",
        "questionFrontendId": "29",
        "questionTitle": "Divide Two Integers",
        "translatedTitle": "两数相除",
        "questionTitleSlug": "divide-two-integers",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"66.4K\", \"totalSubmission\": \"329.3K\", \"totalAcceptedRaw\": 66407, \"totalSubmissionRaw\": 329299, \"acRate\": \"20.2%\"}",
        "translatedContent": "<p>给定两个整数，被除数&nbsp;<code>dividend</code>&nbsp;和除数&nbsp;<code>divisor</code>。将两数相除，要求不使用乘法、除法和 mod 运算符。</p>\n\n<p>返回被除数&nbsp;<code>dividend</code>&nbsp;除以除数&nbsp;<code>divisor</code>&nbsp;得到的商。</p>\n\n<p>整数除法的结果应当截去（<code>truncate</code>）其小数部分，例如：<code>truncate(8.345) = 8</code> 以及 <code>truncate(-2.7335) = -2</code></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> dividend = 10, divisor = 3\n<strong>输出:</strong> 3\n<strong>解释: </strong>10/3 = truncate(3.33333..) = truncate(3) = 3</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> dividend = 7, divisor = -3\n<strong>输出:</strong> -2\n<strong>解释:</strong> 7/-3 = truncate(-2.33333..) = -2</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>被除数和除数均为 32 位有符号整数。</li>\n\t<li>除数不为&nbsp;0。</li>\n\t<li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [&minus;2<sup>31</sup>,&nbsp; 2<sup>31&nbsp;</sup>&minus; 1]。本题中，如果除法结果溢出，则返回 2<sup>31&nbsp;</sup>&minus; 1。</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Math",
                "slug": "math"
            },
            {
                "name": "Binary Search",
                "slug": "binary-search"
            }
        ]
    },
    {
        "questionId": "30",
        "questionFrontendId": "30",
        "questionTitle": "Substring with Concatenation of All Words",
        "translatedTitle": "串联所有单词的子串",
        "questionTitleSlug": "substring-with-concatenation-of-all-words",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"46.9K\", \"totalSubmission\": \"145.2K\", \"totalAcceptedRaw\": 46899, \"totalSubmissionRaw\": 145240, \"acRate\": \"32.3%\"}",
        "translatedContent": "<p>给定一个字符串&nbsp;<strong>s&nbsp;</strong>和一些长度相同的单词&nbsp;<strong>words。</strong>找出 <strong>s </strong>中恰好可以由&nbsp;<strong>words </strong>中所有单词串联形成的子串的起始位置。</p>\n\n<p>注意子串要与&nbsp;<strong>words </strong>中的单词完全匹配，中间不能有其他字符，但不需要考虑&nbsp;<strong>words&nbsp;</strong>中单词串联的顺序。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：\n  s =</strong> &quot;barfoothefoobarman&quot;,\n<strong>  words = </strong>[&quot;foo&quot;,&quot;bar&quot;]\n<strong>输出：</strong><code>[0,9]</code>\n<strong>解释：</strong>\n从索引 0 和 9 开始的子串分别是 &quot;barfoo&quot; 和 &quot;foobar&quot; 。\n输出的顺序不重要, [9,0] 也是有效答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：\n  s =</strong> &quot;wordgoodgoodgoodbestword&quot;,\n<strong>  words = </strong>[&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]\n<code><strong>输出：</strong>[]</code>\n</pre>\n",
        "topicTags": [
            {
                "name": "Hash Table",
                "slug": "hash-table"
            },
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            },
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "31",
        "questionFrontendId": "31",
        "questionTitle": "Next Permutation",
        "translatedTitle": "下一个排列",
        "questionTitleSlug": "next-permutation",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"94.5K\", \"totalSubmission\": \"273.1K\", \"totalAcceptedRaw\": 94492, \"totalSubmissionRaw\": 273109, \"acRate\": \"34.6%\"}",
        "translatedContent": "<p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>\n\n<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>\n\n<p>必须<strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\">原地</a></strong>修改，只允许使用额外常数空间。</p>\n\n<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>\n<code>1,2,3</code> &rarr; <code>1,3,2</code><br>\n<code>3,2,1</code> &rarr; <code>1,2,3</code><br>\n<code>1,1,5</code> &rarr; <code>1,5,1</code></p>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            }
        ]
    },
    {
        "questionId": "32",
        "questionFrontendId": "32",
        "questionTitle": "Longest Valid Parentheses",
        "translatedTitle": "最长有效括号",
        "questionTitleSlug": "longest-valid-parentheses",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"107.5K\", \"totalSubmission\": \"316.6K\", \"totalAcceptedRaw\": 107540, \"totalSubmissionRaw\": 316628, \"acRate\": \"34.0%\"}",
        "translatedContent": "<p>给定一个只包含 <code>&#39;(&#39;</code>&nbsp;和 <code>&#39;)&#39;</code>&nbsp;的字符串，找出最长的包含有效括号的子串的长度。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> &quot;(()&quot;\n<strong>输出:</strong> 2\n<strong>解释:</strong> 最长有效括号子串为 <code>&quot;()&quot;</code>\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> &quot;<code>)()())</code>&quot;\n<strong>输出:</strong> 4\n<strong>解释:</strong> 最长有效括号子串为 <code>&quot;()()&quot;</code>\n</pre>\n",
        "topicTags": [
            {
                "name": "String",
                "slug": "string"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "33",
        "questionFrontendId": "33",
        "questionTitle": "Search in Rotated Sorted Array",
        "translatedTitle": "搜索旋转排序数组",
        "questionTitleSlug": "search-in-rotated-sorted-array",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"182.4K\", \"totalSubmission\": \"464.9K\", \"totalAcceptedRaw\": 182367, \"totalSubmissionRaw\": 464893, \"acRate\": \"39.2%\"}",
        "translatedContent": "<p>给你一个升序排列的整数数组 <code>nums</code> ，和一个整数 <code>target</code> 。</p>\n\n<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。（例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> ）。</p>\n\n<p>请你在数组中搜索 <code>target</code> ，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。</p>\n \n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<code>4,5,6,7,0,1,2]</code>, target = 0\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<code>4,5,6,7,0,1,2]</code>, target = 3\n<strong>输出：</strong>-1</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1], target = 0\n<strong>输出：</strong>-1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 5000</code></li>\n\t<li><code>-10^4 <= nums[i] <= 10^4</code></li>\n\t<li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li>\n\t<li><code>nums</code> 肯定会在某个点上旋转</li>\n\t<li><code>-10^4 <= target <= 10^4</code></li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Binary Search",
                "slug": "binary-search"
            }
        ]
    },
    {
        "questionId": "34",
        "questionFrontendId": "34",
        "questionTitle": "Find First and Last Position of Element in Sorted Array",
        "translatedTitle": "在排序数组中查找元素的第一个和最后一个位置",
        "questionTitleSlug": "find-first-and-last-position-of-element-in-sorted-array",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"141.6K\", \"totalSubmission\": \"349.7K\", \"totalAcceptedRaw\": 141554, \"totalSubmissionRaw\": 349691, \"acRate\": \"40.5%\"}",
        "translatedContent": "<p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p>\n\n<p>你的算法时间复杂度必须是&nbsp;<em>O</em>(log <em>n</em>) 级别。</p>\n\n<p>如果数组中不存在目标值，返回&nbsp;<code>[-1, -1]</code>。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> nums = [<code>5,7,7,8,8,10]</code>, target = 8\n<strong>输出:</strong> [3,4]</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> nums = [<code>5,7,7,8,8,10]</code>, target = 6\n<strong>输出:</strong> [-1,-1]</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Binary Search",
                "slug": "binary-search"
            }
        ]
    },
    {
        "questionId": "35",
        "questionFrontendId": "35",
        "questionTitle": "Search Insert Position",
        "translatedTitle": "搜索插入位置",
        "questionTitleSlug": "search-insert-position",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"264.2K\", \"totalSubmission\": \"565.6K\", \"totalAcceptedRaw\": 264189, \"totalSubmissionRaw\": 565599, \"acRate\": \"46.7%\"}",
        "translatedContent": "<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>\n\n<p>你可以假设数组中无重复元素。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> [1,3,5,6], 5\n<strong>输出:</strong> 2\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> [1,3,5,6], 2\n<strong>输出:</strong> 1\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre><strong>输入:</strong> [1,3,5,6], 7\n<strong>输出:</strong> 4\n</pre>\n\n<p><strong>示例 4:</strong></p>\n\n<pre><strong>输入:</strong> [1,3,5,6], 0\n<strong>输出:</strong> 0\n</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Binary Search",
                "slug": "binary-search"
            }
        ]
    },
    {
        "questionId": "36",
        "questionFrontendId": "36",
        "questionTitle": "Valid Sudoku",
        "translatedTitle": "有效的数独",
        "questionTitleSlug": "valid-sudoku",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"100.8K\", \"totalSubmission\": \"164.6K\", \"totalAcceptedRaw\": 100750, \"totalSubmissionRaw\": 164624, \"acRate\": \"61.2%\"}",
        "translatedContent": "<p>判断一个&nbsp;9x9 的数独是否有效。只需要<strong>根据以下规则</strong>，验证已经填入的数字是否有效即可。</p>\n\n<ol>\n\t<li>数字&nbsp;<code>1-9</code>&nbsp;在每一行只能出现一次。</li>\n\t<li>数字&nbsp;<code>1-9</code>&nbsp;在每一列只能出现一次。</li>\n\t<li>数字&nbsp;<code>1-9</code>&nbsp;在每一个以粗实线分隔的&nbsp;<code>3x3</code>&nbsp;宫内只能出现一次。</li>\n</ol>\n\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png\" style=\"height: 250px; width: 250px;\"></p>\n\n<p><small>上图是一个部分填充的有效的数独。</small></p>\n\n<p>数独部分空格内已填入了数字，空白格用&nbsp;<code>&#39;.&#39;</code>&nbsp;表示。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong>\n[\n  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],\n  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],\n  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],\n  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],\n  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],\n  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],\n  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],\n  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],\n  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]\n]\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong>\n[\n&nbsp; [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],\n&nbsp; [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],\n&nbsp; [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],\n&nbsp; [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],\n&nbsp; [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],\n&nbsp; [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],\n&nbsp; [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],\n&nbsp; [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],\n&nbsp; [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]\n]\n<strong>输出:</strong> false\n<strong>解释:</strong> 除了第一行的第一个数字从<strong> 5</strong> 改为 <strong>8 </strong>以外，空格内其他数字均与 示例1 相同。\n     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</pre>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>一个有效的数独（部分已被填充）不一定是可解的。</li>\n\t<li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>\n\t<li>给定数独序列只包含数字&nbsp;<code>1-9</code>&nbsp;和字符&nbsp;<code>&#39;.&#39;</code>&nbsp;。</li>\n\t<li>给定数独永远是&nbsp;<code>9x9</code>&nbsp;形式的。</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Hash Table",
                "slug": "hash-table"
            }
        ]
    },
    {
        "questionId": "37",
        "questionFrontendId": "37",
        "questionTitle": "Sudoku Solver",
        "translatedTitle": "解数独",
        "questionTitleSlug": "sudoku-solver",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"59.3K\", \"totalSubmission\": \"89K\", \"totalAcceptedRaw\": 59289, \"totalSubmissionRaw\": 88957, \"acRate\": \"66.6%\"}",
        "translatedContent": "<p>编写一个程序，通过填充空格来解决数独问题。</p>\n\n<p>一个数独的解法需<strong>遵循如下规则</strong>：</p>\n\n<ol>\n\t<li>数字&nbsp;<code>1-9</code>&nbsp;在每一行只能出现一次。</li>\n\t<li>数字&nbsp;<code>1-9</code>&nbsp;在每一列只能出现一次。</li>\n\t<li>数字&nbsp;<code>1-9</code>&nbsp;在每一个以粗实线分隔的&nbsp;<code>3x3</code>&nbsp;宫内只能出现一次。</li>\n</ol>\n\n<p>空白格用&nbsp;<code>&#39;.&#39;</code>&nbsp;表示。</p>\n\n<p><img src=\"http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png\"></p>\n\n<p><small>一个数独。</small></p>\n\n<p><img src=\"http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png\"></p>\n\n<p><small>答案被标成红色。</small></p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给定的数独序列只包含数字&nbsp;<code>1-9</code>&nbsp;和字符&nbsp;<code>&#39;.&#39;</code>&nbsp;。</li>\n\t<li>你可以假设给定的数独只有唯一解。</li>\n\t<li>给定数独永远是&nbsp;<code>9x9</code>&nbsp;形式的。</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Hash Table",
                "slug": "hash-table"
            },
            {
                "name": "Backtracking",
                "slug": "backtracking"
            }
        ]
    },
    {
        "questionId": "38",
        "questionFrontendId": "38",
        "questionTitle": "Count and Say",
        "translatedTitle": "外观数列",
        "questionTitleSlug": "count-and-say",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"137.8K\", \"totalSubmission\": \"243.4K\", \"totalAcceptedRaw\": 137779, \"totalSubmissionRaw\": 243355, \"acRate\": \"56.6%\"}",
        "translatedContent": "<p>给定一个正整数 <em>n</em>（1 &le;&nbsp;<em>n</em>&nbsp;&le; 30），输出外观数列的第 <em>n</em> 项。</p>\n\n<p>注意：整数序列中的每一项将表示为一个字符串。</p>\n\n<p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p>\n\n<pre>1.     1\n2.     11\n3.     21\n4.     1211\n5.     111221\n</pre>\n\n<p>第一项是数字 1</p>\n\n<p>描述前一项，这个数是 <code>1</code> 即 &ldquo;一个 1 &rdquo;，记作 <code>11</code></p>\n\n<p>描述前一项，这个数是 <code>11</code> 即 &ldquo;两个 1 &rdquo; ，记作 <code>21</code></p>\n\n<p>描述前一项，这个数是 <code>21</code> 即 &ldquo;一个 2 一个 1 &rdquo; ，记作 <code>1211</code></p>\n\n<p>描述前一项，这个数是 <code>1211</code> 即 &ldquo;一个 1 一个 2 两个 1 &rdquo; ，记作 <code>111221</code></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> 1\n<strong>输出:</strong> &quot;1&quot;\n<strong>解释：</strong>这是一个基本样例。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> 4\n<strong>输出:</strong> &quot;1211&quot;\n<strong>解释：</strong>当 n = 3 时，序列是 &quot;21&quot;，其中我们有 &quot;2&quot; 和 &quot;1&quot; 两组，&quot;2&quot; 可以读作 &quot;12&quot;，也就是出现频次 = 1 而 值 = 2；类似 &quot;1&quot; 可以读作 &quot;11&quot;。所以答案是 &quot;12&quot; 和 &quot;11&quot; 组合在一起，也就是 &quot;1211&quot;。</pre>\n",
        "topicTags": [
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "39",
        "questionFrontendId": "39",
        "questionTitle": "Combination Sum",
        "translatedTitle": "组合总和",
        "questionTitleSlug": "combination-sum",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"173.1K\", \"totalSubmission\": \"242K\", \"totalAcceptedRaw\": 173107, \"totalSubmissionRaw\": 242029, \"acRate\": \"71.5%\"}",
        "translatedContent": "<p>给定一个<strong>无重复元素</strong>的数组&nbsp;<code>candidates</code>&nbsp;和一个目标数&nbsp;<code>target</code>&nbsp;，找出&nbsp;<code>candidates</code>&nbsp;中所有可以使数字和为&nbsp;<code>target</code>&nbsp;的组合。</p>\n\n<p><code>candidates</code>&nbsp;中的数字可以无限制重复被选取。</p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>所有数字（包括&nbsp;<code>target</code>）都是正整数。</li>\n\t<li>解集不能包含重复的组合。&nbsp;</li>\n</ul>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre><strong>输入：</strong>candidates = <code>[2,3,6,7], </code>target = <code>7</code>,\n<strong>所求解集为：</strong>\n[\n  [7],\n  [2,2,3]\n]\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre><strong>输入：</strong>candidates = [2,3,5]<code>, </code>target = 8,\n<strong>所求解集为：</strong>\n[\n&nbsp; [2,2,2,2],\n&nbsp; [2,3,3],\n&nbsp; [3,5]\n]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= candidates.length &lt;= 30</code></li>\n\t<li><code>1 &lt;= candidates[i] &lt;= 200</code></li>\n\t<li><code>candidate</code> 中的每个元素都是独一无二的。</li>\n\t<li><code>1 &lt;= target &lt;= 500</code></li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Backtracking",
                "slug": "backtracking"
            }
        ]
    },
    {
        "questionId": "40",
        "questionFrontendId": "40",
        "questionTitle": "Combination Sum II",
        "translatedTitle": "组合总和 II",
        "questionTitleSlug": "combination-sum-ii",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"113.3K\", \"totalSubmission\": \"175.6K\", \"totalAcceptedRaw\": 113341, \"totalSubmissionRaw\": 175627, \"acRate\": \"64.5%\"}",
        "translatedContent": "<p>给定一个数组&nbsp;<code>candidates</code>&nbsp;和一个目标数&nbsp;<code>target</code>&nbsp;，找出&nbsp;<code>candidates</code>&nbsp;中所有可以使数字和为&nbsp;<code>target</code>&nbsp;的组合。</p>\n\n<p><code>candidates</code>&nbsp;中的每个数字在每个组合中只能使用一次。</p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>所有数字（包括目标数）都是正整数。</li>\n\t<li>解集不能包含重复的组合。&nbsp;</li>\n</ul>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> candidates =&nbsp;<code>[10,1,2,7,6,1,5]</code>, target =&nbsp;<code>8</code>,\n<strong>所求解集为:</strong>\n[\n  [1, 7],\n  [1, 2, 5],\n  [2, 6],\n  [1, 1, 6]\n]\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> candidates =&nbsp;[2,5,2,1,2], target =&nbsp;5,\n<strong>所求解集为:</strong>\n[\n&nbsp; [1,2,2],\n&nbsp; [5]\n]</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Backtracking",
                "slug": "backtracking"
            }
        ]
    },
    {
        "questionId": "41",
        "questionFrontendId": "41",
        "questionTitle": "First Missing Positive",
        "translatedTitle": "缺失的第一个正数",
        "questionTitleSlug": "first-missing-positive",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"94.6K\", \"totalSubmission\": \"234.6K\", \"totalAcceptedRaw\": 94598, \"totalSubmissionRaw\": 234619, \"acRate\": \"40.3%\"}",
        "translatedContent": "<p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>输入: [1,2,0]\n输出: 3\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>输入: [3,4,-1,1]\n输出: 2\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre>输入: [7,8,9,11,12]\n输出: 1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<p>你的算法的时间复杂度应为O(<em>n</em>)，并且只能使用常数级别的额外空间。</p>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            }
        ]
    },
    {
        "questionId": "42",
        "questionFrontendId": "42",
        "questionTitle": "Trapping Rain Water",
        "translatedTitle": "接雨水",
        "questionTitleSlug": "trapping-rain-water",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"157.6K\", \"totalSubmission\": \"298.5K\", \"totalAcceptedRaw\": 157608, \"totalSubmissionRaw\": 298471, \"acRate\": \"52.8%\"}",
        "translatedContent": "<p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png\" style=\"height: 161px; width: 412px;\" /></p>\n\n<pre>\n<strong>输入：</strong>height = [0,1,0,2,1,0,1,3,2,1,2,1]\n<strong>输出：</strong>6\n<strong>解释：</strong>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>height = [4,2,0,3,2,5]\n<strong>输出：</strong>9\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == height.length</code></li>\n\t<li><code>0 <= n <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 <= height[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Stack",
                "slug": "stack"
            },
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            }
        ]
    },
    {
        "questionId": "43",
        "questionFrontendId": "43",
        "questionTitle": "Multiply Strings",
        "translatedTitle": "字符串相乘",
        "questionTitleSlug": "multiply-strings",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"109.7K\", \"totalSubmission\": \"246.4K\", \"totalAcceptedRaw\": 109718, \"totalSubmissionRaw\": 246432, \"acRate\": \"44.5%\"}",
        "translatedContent": "<p>给定两个以字符串形式表示的非负整数&nbsp;<code>num1</code>&nbsp;和&nbsp;<code>num2</code>，返回&nbsp;<code>num1</code>&nbsp;和&nbsp;<code>num2</code>&nbsp;的乘积，它们的乘积也表示为字符串形式。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> num1 = &quot;2&quot;, num2 = &quot;3&quot;\n<strong>输出:</strong> &quot;6&quot;</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> num1 = &quot;123&quot;, num2 = &quot;456&quot;\n<strong>输出:</strong> &quot;56088&quot;</pre>\n\n<p><strong>说明：</strong></p>\n\n<ol>\n\t<li><code>num1</code>&nbsp;和&nbsp;<code>num2</code>&nbsp;的长度小于110。</li>\n\t<li><code>num1</code> 和&nbsp;<code>num2</code> 只包含数字&nbsp;<code>0-9</code>。</li>\n\t<li><code>num1</code> 和&nbsp;<code>num2</code>&nbsp;均不以零开头，除非是数字 0 本身。</li>\n\t<li><strong>不能使用任何标准库的大数类型（比如 BigInteger）</strong>或<strong>直接将输入转换为整数来处理</strong>。</li>\n</ol>\n",
        "topicTags": [
            {
                "name": "Math",
                "slug": "math"
            },
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "44",
        "questionFrontendId": "44",
        "questionTitle": "Wildcard Matching",
        "translatedTitle": "通配符匹配",
        "questionTitleSlug": "wildcard-matching",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"55.3K\", \"totalSubmission\": \"176K\", \"totalAcceptedRaw\": 55321, \"totalSubmissionRaw\": 175966, \"acRate\": \"31.4%\"}",
        "translatedContent": "<p>给定一个字符串&nbsp;(<code>s</code>) 和一个字符模式&nbsp;(<code>p</code>) ，实现一个支持&nbsp;<code>&#39;?&#39;</code>&nbsp;和&nbsp;<code>&#39;*&#39;</code>&nbsp;的通配符匹配。</p>\n\n<pre>&#39;?&#39; 可以匹配任何单个字符。\n&#39;*&#39; 可以匹配任意字符串（包括空字符串）。\n</pre>\n\n<p>两个字符串<strong>完全匹配</strong>才算匹配成功。</p>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li><code>s</code>&nbsp;可能为空，且只包含从&nbsp;<code>a-z</code>&nbsp;的小写字母。</li>\n\t<li><code>p</code>&nbsp;可能为空，且只包含从&nbsp;<code>a-z</code>&nbsp;的小写字母，以及字符&nbsp;<code>?</code>&nbsp;和&nbsp;<code>*</code>。</li>\n</ul>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong>\ns = &quot;aa&quot;\np = &quot;a&quot;\n<strong>输出:</strong> false\n<strong>解释:</strong> &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong>\ns = &quot;aa&quot;\np = &quot;*&quot;\n<strong>输出:</strong> true\n<strong>解释:</strong>&nbsp;&#39;*&#39; 可以匹配任意字符串。\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre><strong>输入:</strong>\ns = &quot;cb&quot;\np = &quot;?a&quot;\n<strong>输出:</strong> false\n<strong>解释:</strong>&nbsp;&#39;?&#39; 可以匹配 &#39;c&#39;, 但第二个 &#39;a&#39; 无法匹配 &#39;b&#39;。\n</pre>\n\n<p><strong>示例&nbsp;4:</strong></p>\n\n<pre><strong>输入:</strong>\ns = &quot;adceb&quot;\np = &quot;*a*b&quot;\n<strong>输出:</strong> true\n<strong>解释:</strong>&nbsp;第一个 &#39;*&#39; 可以匹配空字符串, 第二个 &#39;*&#39; 可以匹配字符串 &quot;dce&quot;.\n</pre>\n\n<p><strong>示例&nbsp;5:</strong></p>\n\n<pre><strong>输入:</strong>\ns = &quot;acdcb&quot;\np = &quot;a*c?b&quot;\n<strong>输出:</strong> false</pre>\n",
        "topicTags": [
            {
                "name": "Greedy",
                "slug": "greedy"
            },
            {
                "name": "String",
                "slug": "string"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            },
            {
                "name": "Backtracking",
                "slug": "backtracking"
            }
        ]
    },
    {
        "questionId": "45",
        "questionFrontendId": "45",
        "questionTitle": "Jump Game II",
        "translatedTitle": "跳跃游戏 II",
        "questionTitleSlug": "jump-game-ii",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"87.1K\", \"totalSubmission\": \"230.3K\", \"totalAcceptedRaw\": 87138, \"totalSubmissionRaw\": 230280, \"acRate\": \"37.8%\"}",
        "translatedContent": "<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>\n\n<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n\n<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> [2,3,1,1,4]\n<strong>输出:</strong> 2\n<strong>解释:</strong> 跳到最后一个位置的最小跳跃数是 <code>2</code>。\n&nbsp;    从下标为 0 跳到下标为 1 的位置，跳&nbsp;<code>1</code>&nbsp;步，然后跳&nbsp;<code>3</code>&nbsp;步到达数组的最后一个位置。\n</pre>\n\n<p><strong>说明:</strong></p>\n\n<p>假设你总是可以到达数组的最后一个位置。</p>\n",
        "topicTags": [
            {
                "name": "Greedy",
                "slug": "greedy"
            },
            {
                "name": "Array",
                "slug": "array"
            }
        ]
    },
    {
        "questionId": "46",
        "questionFrontendId": "46",
        "questionTitle": "Permutations",
        "translatedTitle": "全排列",
        "questionTitleSlug": "permutations",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"208.3K\", \"totalSubmission\": \"270.4K\", \"totalAcceptedRaw\": 208293, \"totalSubmissionRaw\": 270425, \"acRate\": \"77.0%\"}",
        "translatedContent": "<p>给定一个<strong> 没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> [1,2,3]\n<strong>输出:</strong>\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]</pre>\n",
        "topicTags": [
            {
                "name": "Backtracking",
                "slug": "backtracking"
            }
        ]
    },
    {
        "questionId": "47",
        "questionFrontendId": "47",
        "questionTitle": "Permutations II",
        "translatedTitle": "全排列 II",
        "questionTitleSlug": "permutations-ii",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"115.8K\", \"totalSubmission\": \"186.6K\", \"totalAcceptedRaw\": 115833, \"totalSubmissionRaw\": 186586, \"acRate\": \"62.1%\"}",
        "translatedContent": "<p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> [1,1,2]\n<strong>输出:</strong>\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]</pre>\n",
        "topicTags": [
            {
                "name": "Backtracking",
                "slug": "backtracking"
            }
        ]
    },
    {
        "questionId": "48",
        "questionFrontendId": "48",
        "questionTitle": "Rotate Image",
        "translatedTitle": "旋转图像",
        "questionTitleSlug": "rotate-image",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"104.6K\", \"totalSubmission\": \"149.6K\", \"totalAcceptedRaw\": 104618, \"totalSubmissionRaw\": 149611, \"acRate\": \"69.9%\"}",
        "translatedContent": "<p>给定一个 <em>n&nbsp;</em>&times;&nbsp;<em>n</em> 的二维矩阵表示一个图像。</p>\n\n<p>将图像顺时针旋转 90 度。</p>\n\n<p><strong>说明：</strong></p>\n\n<p>你必须在<strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\">原地</a></strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>给定 <strong>matrix</strong> = \n[\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n],\n\n<strong>原地</strong>旋转输入矩阵，使其变为:\n[\n  [7,4,1],\n  [8,5,2],\n  [9,6,3]\n]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>给定 <strong>matrix</strong> =\n[\n  [ 5, 1, 9,11],\n  [ 2, 4, 8,10],\n  [13, 3, 6, 7],\n  [15,14,12,16]\n], \n\n<strong>原地</strong>旋转输入矩阵，使其变为:\n[\n  [15,13, 2, 5],\n  [14, 3, 4, 1],\n  [12, 6, 8, 9],\n  [16, 7,10,11]\n]\n</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            }
        ]
    },
    {
        "questionId": "49",
        "questionFrontendId": "49",
        "questionTitle": "Group Anagrams",
        "translatedTitle": "字母异位词分组",
        "questionTitleSlug": "group-anagrams",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"113.6K\", \"totalSubmission\": \"178K\", \"totalAcceptedRaw\": 113647, \"totalSubmissionRaw\": 177968, \"acRate\": \"63.9%\"}",
        "translatedContent": "<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> <code>[&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</code>\n<strong>输出:</strong>\n[\n  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],\n  [&quot;nat&quot;,&quot;tan&quot;],\n  [&quot;bat&quot;]\n]</pre>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>所有输入均为小写字母。</li>\n\t<li>不考虑答案输出的顺序。</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Hash Table",
                "slug": "hash-table"
            },
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "50",
        "questionFrontendId": "50",
        "questionTitle": "Pow(x, n)",
        "translatedTitle": "Pow(x, n)",
        "questionTitleSlug": "powx-n",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"133.5K\", \"totalSubmission\": \"362.9K\", \"totalAcceptedRaw\": 133542, \"totalSubmissionRaw\": 362882, \"acRate\": \"36.8%\"}",
        "translatedContent": "<p>实现&nbsp;<a href=\"https://www.cplusplus.com/reference/valarray/pow/\" target=\"_blank\">pow(<em>x</em>, <em>n</em>)</a>&nbsp;，即计算 x 的 n 次幂函数。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> 2.00000, 10\n<strong>输出:</strong> 1024.00000\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> 2.10000, 3\n<strong>输出:</strong> 9.26100\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre><strong>输入:</strong> 2.00000, -2\n<strong>输出:</strong> 0.25000\n<strong>解释:</strong> 2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25</pre>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>-100.0 &lt;&nbsp;<em>x</em>&nbsp;&lt; 100.0</li>\n\t<li><em>n</em>&nbsp;是 32 位有符号整数，其数值范围是&nbsp;[&minus;2<sup>31</sup>,&nbsp;2<sup>31&nbsp;</sup>&minus; 1] 。</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Math",
                "slug": "math"
            },
            {
                "name": "Binary Search",
                "slug": "binary-search"
            }
        ]
    },
    {
        "questionId": "51",
        "questionFrontendId": "51",
        "questionTitle": "N-Queens",
        "translatedTitle": "N 皇后",
        "questionTitleSlug": "n-queens",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"84.3K\", \"totalSubmission\": \"115.1K\", \"totalAcceptedRaw\": 84344, \"totalSubmissionRaw\": 115058, \"acRate\": \"73.3%\"}",
        "translatedContent": "<p><em>n&nbsp;</em>皇后问题研究的是如何将 <em>n</em>&nbsp;个皇后放置在 <em>n</em>&times;<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/8-queens.png\"></p>\n\n<p><small>上图为 8 皇后问题的一种解法。</small></p>\n\n<p>给定一个整数 <em>n</em>，返回所有不同的&nbsp;<em>n&nbsp;</em>皇后问题的解决方案。</p>\n\n<p>每一种解法包含一个明确的&nbsp;<em>n</em> 皇后问题的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>4\n<strong>输出：</strong>[\n [&quot;.Q..&quot;,  // 解法 1\n  &quot;...Q&quot;,\n  &quot;Q...&quot;,\n  &quot;..Q.&quot;],\n\n [&quot;..Q.&quot;,  // 解法 2\n  &quot;Q...&quot;,\n  &quot;...Q&quot;,\n  &quot;.Q..&quot;]\n]\n<strong>解释:</strong> 4 皇后问题存在两个不同的解法。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Backtracking",
                "slug": "backtracking"
            }
        ]
    },
    {
        "questionId": "52",
        "questionFrontendId": "52",
        "questionTitle": "N-Queens II",
        "translatedTitle": "N皇后 II",
        "questionTitleSlug": "n-queens-ii",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"48.5K\", \"totalSubmission\": \"59K\", \"totalAcceptedRaw\": 48459, \"totalSubmissionRaw\": 59015, \"acRate\": \"82.1%\"}",
        "translatedContent": "<p><em>n&nbsp;</em>皇后问题研究的是如何将 <em>n</em>&nbsp;个皇后放置在 <em>n</em>&times;<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/8-queens.png\" style=\"height: 276px; width: 258px;\"></p>\n\n<p><small>上图为 8 皇后问题的一种解法。</small></p>\n\n<p>给定一个整数 <em>n</em>，返回 <em>n</em> 皇后不同的解决方案的数量。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> 4\n<strong>输出:</strong> 2\n<strong>解释:</strong> 4 皇后问题存在如下两个不同的解法。\n[\n&nbsp;[&quot;.Q..&quot;, &nbsp;// 解法 1\n&nbsp; &quot;...Q&quot;,\n&nbsp; &quot;Q...&quot;,\n&nbsp; &quot;..Q.&quot;],\n\n&nbsp;[&quot;..Q.&quot;, &nbsp;// 解法 2\n&nbsp; &quot;Q...&quot;,\n&nbsp; &quot;...Q&quot;,\n&nbsp; &quot;.Q..&quot;]\n]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><strong>皇后</strong>，是<a href=\"https://baike.baidu.com/item/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B\" target=\"_blank\">国际象棋</a>中的棋子，意味着<a href=\"https://baike.baidu.com/item/%E5%9B%BD%E7%8E%8B\" target=\"_blank\">国王</a>的妻子。皇后只做一件事，那就是&ldquo;<a href=\"https://baike.baidu.com/item/%E5%90%83%E5%AD%90\" target=\"_blank\">吃子</a>&rdquo;。当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一或 N-1 步，可进可退。（引用自 <a href=\"https://baike.baidu.com/item/%E7%9A%87%E5%90%8E/15860305?fr=aladdin\">百度百科 - 皇后</a> ）</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Backtracking",
                "slug": "backtracking"
            }
        ]
    },
    {
        "questionId": "53",
        "questionFrontendId": "53",
        "questionTitle": "Maximum Subarray",
        "translatedTitle": "最大子序和",
        "questionTitleSlug": "maximum-subarray",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"348.2K\", \"totalSubmission\": \"662.3K\", \"totalAcceptedRaw\": 348173, \"totalSubmissionRaw\": 662336, \"acRate\": \"52.6%\"}",
        "translatedContent": "<p>给定一个整数数组 <code>nums</code>&nbsp;，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> [-2,1,-3,4,-1,2,1,-5,4]\n<strong>输出:</strong> 6\n<strong>解释:</strong>&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。\n</pre>\n\n<p><strong>进阶:</strong></p>\n\n<p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Divide and Conquer",
                "slug": "divide-and-conquer"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "54",
        "questionFrontendId": "54",
        "questionTitle": "Spiral Matrix",
        "translatedTitle": "螺旋矩阵",
        "questionTitleSlug": "spiral-matrix",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"86.7K\", \"totalSubmission\": \"209.7K\", \"totalAcceptedRaw\": 86744, \"totalSubmissionRaw\": 209739, \"acRate\": \"41.4%\"}",
        "translatedContent": "<p>给定一个包含&nbsp;<em>m</em> x <em>n</em>&nbsp;个元素的矩阵（<em>m</em> 行, <em>n</em> 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong>\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n<strong>输出:</strong> [1,2,3,6,9,8,7,4,5]\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong>\n[\n  [1, 2, 3, 4],\n  [5, 6, 7, 8],\n  [9,10,11,12]\n]\n<strong>输出:</strong> [1,2,3,4,8,12,11,10,9,5,6,7]\n</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            }
        ]
    },
    {
        "questionId": "55",
        "questionFrontendId": "55",
        "questionTitle": "Jump Game",
        "translatedTitle": "跳跃游戏",
        "questionTitleSlug": "jump-game",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"162.4K\", \"totalSubmission\": \"394.4K\", \"totalAcceptedRaw\": 162446, \"totalSubmissionRaw\": 394376, \"acRate\": \"41.2%\"}",
        "translatedContent": "<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>\n\n<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n\n<p>判断你是否能够到达最后一个位置。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> [2,3,1,1,4]\n<strong>输出:</strong> true\n<strong>解释:</strong> 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> [3,2,1,0,4]\n<strong>输出:</strong> false\n<strong>解释:</strong> 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。\n</pre>\n",
        "topicTags": [
            {
                "name": "Greedy",
                "slug": "greedy"
            },
            {
                "name": "Array",
                "slug": "array"
            }
        ]
    },
    {
        "questionId": "56",
        "questionFrontendId": "56",
        "questionTitle": "Merge Intervals",
        "translatedTitle": "合并区间",
        "questionTitleSlug": "merge-intervals",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"155.1K\", \"totalSubmission\": \"359.1K\", \"totalAcceptedRaw\": 155090, \"totalSubmissionRaw\": 359147, \"acRate\": \"43.2%\"}",
        "translatedContent": "<p>给出一个区间的集合，请合并所有重叠的区间。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> intervals = [[1,3],[2,6],[8,10],[15,18]]\n<strong>输出:</strong> [[1,6],[8,10],[15,18]]\n<strong>解释:</strong> 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> intervals = [[1,4],[4,5]]\n<strong>输出:</strong> [[1,5]]\n<strong>解释:</strong> 区间 [1,4] 和 [4,5] 可被视为重叠区间。</pre>\n\n<p><strong>注意：</strong>输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>intervals[i][0] &lt;= intervals[i][1]</code></li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Sort",
                "slug": "sort"
            },
            {
                "name": "Array",
                "slug": "array"
            }
        ]
    },
    {
        "questionId": "57",
        "questionFrontendId": "57",
        "questionTitle": "Insert Interval",
        "translatedTitle": "插入区间",
        "questionTitleSlug": "insert-interval",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"32.1K\", \"totalSubmission\": \"84.6K\", \"totalAcceptedRaw\": 32126, \"totalSubmissionRaw\": 84600, \"acRate\": \"38.0%\"}",
        "translatedContent": "<p>给出一个<em>无重叠的 ，</em>按照区间起始端点排序的区间列表。</p>\n\n<p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre><strong>输入：</strong>intervals = [[1,3],[6,9]], newInterval = [2,5]\n<strong>输出：</strong>[[1,5],[6,9]]\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre><strong>输入：</strong>intervals = <code>[[1,2],[3,5],[6,7],[8,10],[12,16]]</code>, newInterval = <code>[4,8]</code>\n<strong>输出：</strong>[[1,2],[3,10],[12,16]]\n<strong>解释：</strong>这是因为新的区间 <code>[4,8]</code> 与 <code>[3,5],[6,7],[8,10]</code>&nbsp;重叠。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>输入类型已在 2019 年 4 月 15 日更改。请重置为默认代码定义以获取新的方法签名。</p>\n",
        "topicTags": [
            {
                "name": "Sort",
                "slug": "sort"
            },
            {
                "name": "Array",
                "slug": "array"
            }
        ]
    },
    {
        "questionId": "58",
        "questionFrontendId": "58",
        "questionTitle": "Length of Last Word",
        "translatedTitle": "最后一个单词的长度",
        "questionTitleSlug": "length-of-last-word",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"132.7K\", \"totalSubmission\": \"392.8K\", \"totalAcceptedRaw\": 132669, \"totalSubmissionRaw\": 392798, \"acRate\": \"33.8%\"}",
        "translatedContent": "<p>给定一个仅包含大小写字母和空格&nbsp;<code>&#39; &#39;</code>&nbsp;的字符串 <code>s</code>，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。</p>\n\n<p>如果不存在最后一个单词，请返回 0&nbsp;。</p>\n\n<p><strong>说明：</strong>一个单词是指仅由字母组成、不包含任何空格字符的 <strong>最大子字符串</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> &quot;Hello World&quot;\n<strong>输出:</strong> 5\n</pre>\n",
        "topicTags": [
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "59",
        "questionFrontendId": "59",
        "questionTitle": "Spiral Matrix II",
        "translatedTitle": "螺旋矩阵 II",
        "questionTitleSlug": "spiral-matrix-ii",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"50K\", \"totalSubmission\": \"63.8K\", \"totalAcceptedRaw\": 50011, \"totalSubmissionRaw\": 63815, \"acRate\": \"78.4%\"}",
        "translatedContent": "<p>给定一个正整数&nbsp;<em>n</em>，生成一个包含 1 到&nbsp;<em>n</em><sup>2</sup>&nbsp;所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> 3\n<strong>输出:</strong>\n[\n [ 1, 2, 3 ],\n [ 8, 9, 4 ],\n [ 7, 6, 5 ]\n]</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            }
        ]
    },
    {
        "questionId": "60",
        "questionFrontendId": "60",
        "questionTitle": "Permutation Sequence",
        "translatedTitle": "第k个排列",
        "questionTitleSlug": "permutation-sequence",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"66K\", \"totalSubmission\": \"128.2K\", \"totalAcceptedRaw\": 66027, \"totalSubmissionRaw\": 128184, \"acRate\": \"51.5%\"}",
        "translatedContent": "<p>给出集合&nbsp;<code>[1,2,3,&hellip;,<em>n</em>]</code>，其所有元素共有&nbsp;<em>n</em>! 种排列。</p>\n\n<p>按大小顺序列出所有排列情况，并一一标记，当&nbsp;<em>n </em>= 3 时, 所有排列如下：</p>\n\n<ol>\n\t<li><code>&quot;123&quot;</code></li>\n\t<li><code>&quot;132&quot;</code></li>\n\t<li><code>&quot;213&quot;</code></li>\n\t<li><code>&quot;231&quot;</code></li>\n\t<li><code>&quot;312&quot;</code></li>\n\t<li><code>&quot;321&quot;</code></li>\n</ol>\n\n<p>给定&nbsp;<em>n</em> 和&nbsp;<em>k</em>，返回第&nbsp;<em>k</em>&nbsp;个排列。</p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>给定<em> n</em>&nbsp;的范围是 [1, 9]。</li>\n\t<li>给定 <em>k&nbsp;</em>的范围是[1, &nbsp;<em>n</em>!]。</li>\n</ul>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> n = 3, k = 3\n<strong>输出:</strong> &quot;213&quot;\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> n = 4, k = 9\n<strong>输出:</strong> &quot;2314&quot;\n</pre>\n",
        "topicTags": [
            {
                "name": "Math",
                "slug": "math"
            },
            {
                "name": "Backtracking",
                "slug": "backtracking"
            }
        ]
    },
    {
        "questionId": "61",
        "questionFrontendId": "61",
        "questionTitle": "Rotate List",
        "translatedTitle": "旋转链表",
        "questionTitleSlug": "rotate-list",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"91.5K\", \"totalSubmission\": \"225.9K\", \"totalAcceptedRaw\": 91477, \"totalSubmissionRaw\": 225862, \"acRate\": \"40.5%\"}",
        "translatedContent": "<p>给定一个链表，旋转链表，将链表每个节点向右移动&nbsp;<em>k&nbsp;</em>个位置，其中&nbsp;<em>k&nbsp;</em>是非负数。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2\n<strong>输出:</strong> 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL\n<strong>解释:</strong>\n向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL\n向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> 0-&gt;1-&gt;2-&gt;NULL, k = 4\n<strong>输出:</strong> <code>2-&gt;0-&gt;1-&gt;NULL</code>\n<strong>解释:</strong>\n向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL\n向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL\n向右旋转 3 步:&nbsp;<code>0-&gt;1-&gt;2-&gt;NULL</code>\n向右旋转 4 步:&nbsp;<code>2-&gt;0-&gt;1-&gt;NULL</code></pre>\n",
        "topicTags": [
            {
                "name": "Linked List",
                "slug": "linked-list"
            },
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            }
        ]
    },
    {
        "questionId": "62",
        "questionFrontendId": "62",
        "questionTitle": "Unique Paths",
        "translatedTitle": "不同路径",
        "questionTitleSlug": "unique-paths",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"155.7K\", \"totalSubmission\": \"249.1K\", \"totalAcceptedRaw\": 155657, \"totalSubmissionRaw\": 249085, \"acRate\": \"62.5%\"}",
        "translatedContent": "<p>一个机器人位于一个 <em>m x n </em>网格的左上角 （起始点在下图中标记为&ldquo;Start&rdquo; ）。</p>\n\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为&ldquo;Finish&rdquo;）。</p>\n\n<p>问总共有多少条不同的路径？</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png\"></p>\n\n<p><small>例如，上图是一个7 x 3 的网格。有多少可能的路径？</small></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> m = 3, n = 2\n<strong>输出:</strong> 3\n<strong>解释:</strong>\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -&gt; 向右 -&gt; 向下\n2. 向右 -&gt; 向下 -&gt; 向右\n3. 向下 -&gt; 向右 -&gt; 向右\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> m = 7, n = 3\n<strong>输出:</strong> 28</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li>题目数据保证答案小于等于 <code>2 * 10 ^ 9</code></li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "63",
        "questionFrontendId": "63",
        "questionTitle": "Unique Paths II",
        "translatedTitle": "不同路径 II",
        "questionTitleSlug": "unique-paths-ii",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"105.7K\", \"totalSubmission\": \"286.3K\", \"totalAcceptedRaw\": 105682, \"totalSubmissionRaw\": 286329, \"acRate\": \"36.9%\"}",
        "translatedContent": "<p>一个机器人位于一个 <em>m x n </em>网格的左上角 （起始点在下图中标记为&ldquo;Start&rdquo; ）。</p>\n\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为&ldquo;Finish&rdquo;）。</p>\n\n<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png\" style=\"height: 183px; width: 400px;\"></p>\n\n<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>\n\n<p><strong>说明：</strong><em>m</em>&nbsp;和 <em>n </em>的值均不超过 100。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:\n</strong>[\n&nbsp; [0,0,0],\n&nbsp; [0,1,0],\n&nbsp; [0,0,0]\n]\n<strong>输出:</strong> 2\n<strong>解释:</strong>\n3x3 网格的正中间有一个障碍物。\n从左上角到右下角一共有 <code>2</code> 条不同的路径：\n1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下\n2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右\n</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "64",
        "questionFrontendId": "64",
        "questionTitle": "Minimum Path Sum",
        "translatedTitle": "最小路径和",
        "questionTitleSlug": "minimum-path-sum",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"153.2K\", \"totalSubmission\": \"226.6K\", \"totalAcceptedRaw\": 153164, \"totalSubmissionRaw\": 226625, \"acRate\": \"67.6%\"}",
        "translatedContent": "<p>给定一个包含非负整数的 <em>m</em>&nbsp;x&nbsp;<em>n</em>&nbsp;网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>\n\n<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong>\n[\n&nbsp; [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n<strong>输出:</strong> 7\n<strong>解释:</strong> 因为路径 1&rarr;3&rarr;1&rarr;1&rarr;1 的总和最小。\n</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "65",
        "questionFrontendId": "65",
        "questionTitle": "Valid Number",
        "translatedTitle": "有效数字",
        "questionTitleSlug": "valid-number",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"19.6K\", \"totalSubmission\": \"92.9K\", \"totalAcceptedRaw\": 19569, \"totalSubmissionRaw\": 92926, \"acRate\": \"21.1%\"}",
        "translatedContent": "<p>验证给定的字符串是否可以解释为十进制数字。</p>\n\n<p>例如:</p>\n\n<p><code>&quot;0&quot;</code>&nbsp;=&gt;&nbsp;<code>true</code><br>\n<code>&quot; 0.1 &quot;</code>&nbsp;=&gt;&nbsp;<code>true</code><br>\n<code>&quot;abc&quot;</code>&nbsp;=&gt;&nbsp;<code>false</code><br>\n<code>&quot;1 a&quot;</code>&nbsp;=&gt;&nbsp;<code>false</code><br>\n<code>&quot;2e10&quot;</code>&nbsp;=&gt;&nbsp;<code>true</code><br>\n<code>&quot; -90e3&nbsp; &nbsp;&quot;</code>&nbsp;=&gt;&nbsp;<code>true</code><br>\n<code>&quot; 1e&quot;</code>&nbsp;=&gt;&nbsp;<code>false</code><br>\n<code>&quot;e3&quot;</code>&nbsp;=&gt;&nbsp;<code>false</code><br>\n<code>&quot; 6e-1&quot;</code>&nbsp;=&gt;&nbsp;<code>true</code><br>\n<code>&quot; 99e2.5&nbsp;&quot;</code>&nbsp;=&gt;&nbsp;<code>false</code><br>\n<code>&quot;53.5e93&quot;</code>&nbsp;=&gt;&nbsp;<code>true</code><br>\n<code>&quot; --6 &quot;</code>&nbsp;=&gt;&nbsp;<code>false</code><br>\n<code>&quot;-+3&quot;</code>&nbsp;=&gt;&nbsp;<code>false</code><br>\n<code>&quot;95a54e53&quot;</code>&nbsp;=&gt;&nbsp;<code>false</code></p>\n\n<p><strong>说明:</strong>&nbsp;我们有意将问题陈述地比较模糊。在实现代码之前，你应当事先思考所有可能的情况。这里给出一份可能存在于有效十进制数字中的字符列表：</p>\n\n<ul>\n\t<li>数字 0-9</li>\n\t<li>指数 - &quot;e&quot;</li>\n\t<li>正/负号 - &quot;+&quot;/&quot;-&quot;</li>\n\t<li>小数点 - &quot;.&quot;</li>\n</ul>\n\n<p>当然，在输入中，这些字符的上下文也很重要。</p>\n\n<p><strong>更新于 2015-02-10:</strong><br>\n<code>C++</code>函数的形式已经更新了。如果你仍然看见你的函数接收&nbsp;<code>const char *</code> 类型的参数，请点击重载按钮重置你的代码。</p>\n",
        "topicTags": [
            {
                "name": "Math",
                "slug": "math"
            },
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "66",
        "questionFrontendId": "66",
        "questionTitle": "Plus One",
        "translatedTitle": "加一",
        "questionTitleSlug": "plus-one",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"213K\", \"totalSubmission\": \"467.6K\", \"totalAcceptedRaw\": 213040, \"totalSubmissionRaw\": 467628, \"acRate\": \"45.6%\"}",
        "translatedContent": "<p>给定一个由<strong>整数</strong>组成的<strong>非空</strong>数组所表示的非负整数，在该数的基础上加一。</p>\n\n<p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p>\n\n<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> [1,2,3]\n<strong>输出:</strong> [1,2,4]\n<strong>解释:</strong> 输入数组表示数字 123。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> [4,3,2,1]\n<strong>输出:</strong> [4,3,2,2]\n<strong>解释:</strong> 输入数组表示数字 4321。\n</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            }
        ]
    },
    {
        "questionId": "67",
        "questionFrontendId": "67",
        "questionTitle": "Add Binary",
        "translatedTitle": "二进制求和",
        "questionTitleSlug": "add-binary",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"131.3K\", \"totalSubmission\": \"241.5K\", \"totalAcceptedRaw\": 131313, \"totalSubmissionRaw\": 241486, \"acRate\": \"54.4%\"}",
        "translatedContent": "<p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p>\n\n<p>输入为 <strong>非空 </strong>字符串且只包含数字&nbsp;<code>1</code>&nbsp;和&nbsp;<code>0</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> a = &quot;11&quot;, b = &quot;1&quot;\n<strong>输出:</strong> &quot;100&quot;</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> a = &quot;1010&quot;, b = &quot;1011&quot;\n<strong>输出:</strong> &quot;10101&quot;</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每个字符串仅由字符 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code> 组成。</li>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 10^4</code></li>\n\t<li>字符串如果不是 <code>&quot;0&quot;</code> ，就都不含前导零。</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Math",
                "slug": "math"
            },
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "68",
        "questionFrontendId": "68",
        "questionTitle": "Text Justification",
        "translatedTitle": "文本左右对齐",
        "questionTitleSlug": "text-justification",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"12.1K\", \"totalSubmission\": \"27.1K\", \"totalAcceptedRaw\": 12123, \"totalSubmissionRaw\": 27098, \"acRate\": \"44.7%\"}",
        "translatedContent": "<p>给定一个单词数组和一个长度&nbsp;<em>maxWidth</em>，重新排版单词，使其成为每行恰好有&nbsp;<em>maxWidth</em>&nbsp;个字符，且左右两端对齐的文本。</p>\n\n<p>你应该使用&ldquo;贪心算法&rdquo;来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格&nbsp;<code>&#39; &#39;</code>&nbsp;填充，使得每行恰好有 <em>maxWidth</em>&nbsp;个字符。</p>\n\n<p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p>\n\n<p>文本的最后一行应为左对齐，且单词之间不插入<strong>额外的</strong>空格。</p>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>单词是指由非空格字符组成的字符序列。</li>\n\t<li>每个单词的长度大于 0，小于等于&nbsp;<em>maxWidth</em>。</li>\n\t<li>输入单词数组 <code>words</code>&nbsp;至少包含一个单词。</li>\n</ul>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong>\nwords = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]\nmaxWidth = 16\n<strong>输出:</strong>\n[\n&nbsp; &nbsp;&quot;This &nbsp; &nbsp;is &nbsp; &nbsp;an&quot;,\n&nbsp; &nbsp;&quot;example &nbsp;of text&quot;,\n&nbsp; &nbsp;&quot;justification. &nbsp;&quot;\n]\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong>\nwords = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;]\nmaxWidth = 16\n<strong>输出:</strong>\n[\n&nbsp; &quot;What &nbsp; must &nbsp; be&quot;,\n&nbsp; &quot;acknowledgment &nbsp;&quot;,\n&nbsp; &quot;shall be &nbsp; &nbsp; &nbsp; &nbsp;&quot;\n]\n<strong>解释: </strong>注意最后一行的格式应为 &quot;shall be    &quot; 而不是 &quot;shall     be&quot;,\n&nbsp;    因为最后一行应为左对齐，而不是左右两端对齐。       \n     第二行同样为左对齐，这是因为这行只包含一个单词。\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre><strong>输入:</strong>\nwords = [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,\n&nbsp;        &quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;]\nmaxWidth = 20\n<strong>输出:</strong>\n[\n&nbsp; &quot;Science &nbsp;is &nbsp;what we&quot;,\n  &quot;understand &nbsp; &nbsp; &nbsp;well&quot;,\n&nbsp; &quot;enough to explain to&quot;,\n&nbsp; &quot;a &nbsp;computer. &nbsp;Art is&quot;,\n&nbsp; &quot;everything &nbsp;else &nbsp;we&quot;,\n&nbsp; &quot;do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;\n]\n</pre>\n",
        "topicTags": [
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "69",
        "questionFrontendId": "69",
        "questionTitle": "Sqrt(x)",
        "translatedTitle": "x 的平方根",
        "questionTitleSlug": "sqrtx",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"216K\", \"totalSubmission\": \"555.1K\", \"totalAcceptedRaw\": 215960, \"totalSubmissionRaw\": 555117, \"acRate\": \"38.9%\"}",
        "translatedContent": "<p>实现&nbsp;<code>int sqrt(int x)</code>&nbsp;函数。</p>\n\n<p>计算并返回&nbsp;<em>x</em>&nbsp;的平方根，其中&nbsp;<em>x </em>是非负整数。</p>\n\n<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> 4\n<strong>输出:</strong> 2\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> 8\n<strong>输出:</strong> 2\n<strong>说明:</strong> 8 的平方根是 2.82842..., \n&nbsp;    由于返回类型是整数，小数部分将被舍去。\n</pre>\n",
        "topicTags": [
            {
                "name": "Math",
                "slug": "math"
            },
            {
                "name": "Binary Search",
                "slug": "binary-search"
            }
        ]
    },
    {
        "questionId": "70",
        "questionFrontendId": "70",
        "questionTitle": "Climbing Stairs",
        "translatedTitle": "爬楼梯",
        "questionTitleSlug": "climbing-stairs",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"303.6K\", \"totalSubmission\": \"598.5K\", \"totalAcceptedRaw\": 303625, \"totalSubmissionRaw\": 598463, \"acRate\": \"50.7%\"}",
        "translatedContent": "<p>假设你正在爬楼梯。需要 <em>n</em>&nbsp;阶你才能到达楼顶。</p>\n\n<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n\n<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong> 2\n<strong>输出：</strong> 2\n<strong>解释：</strong> 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong> 3\n<strong>输出：</strong> 3\n<strong>解释：</strong> 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n</pre>\n",
        "topicTags": [
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "71",
        "questionFrontendId": "71",
        "questionTitle": "Simplify Path",
        "translatedTitle": "简化路径",
        "questionTitleSlug": "simplify-path",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"57.9K\", \"totalSubmission\": \"141.7K\", \"totalAcceptedRaw\": 57867, \"totalSubmissionRaw\": 141668, \"acRate\": \"40.8%\"}",
        "translatedContent": "<p>以 Unix 风格给出一个文件的<strong>绝对路径</strong>，你需要简化它。或者换句话说，将其转换为规范路径。</p>\n\n<p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>）&nbsp;表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：<a href=\"https://blog.csdn.net/u011327334/article/details/50355600\" target=\"_blank\">Linux / Unix中的绝对路径 vs 相对路径</a></p>\n\n<p>请注意，返回的规范路径必须始终以斜杠 <code>/</code> 开头，并且两个目录名之间必须只有一个斜杠 <code>/</code>。最后一个目录名（如果存在）<strong>不能</strong>以 <code>/</code> 结尾。此外，规范路径必须是表示绝对路径的<strong>最短</strong>字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：&quot;</strong>/home/&quot;\n<strong>输出：&quot;</strong>/home&quot;\n<strong>解释：</strong>注意，最后一个目录名后面没有斜杠。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：&quot;</strong>/../&quot;\n<strong>输出：&quot;</strong>/&quot;\n<strong>解释：</strong>从根目录向上一级是不可行的，因为根是你可以到达的最高级。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：&quot;</strong>/home//foo/&quot;\n<strong>输出：&quot;</strong>/home/foo&quot;\n<strong>解释：</strong>在规范路径中，多个连续斜杠需要用一个斜杠替换。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：&quot;</strong>/a/./b/../../c/&quot;\n<strong>输出：&quot;</strong>/c&quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：&quot;</strong>/a/../../b/../c//.//&quot;\n<strong>输出：&quot;</strong>/c&quot;\n</pre>\n\n<p><strong>示例 6：</strong></p>\n\n<pre><strong>输入：&quot;</strong>/a//b////c/d//././/..&quot;\n<strong>输出：&quot;</strong>/a/b/c&quot;</pre>\n",
        "topicTags": [
            {
                "name": "Stack",
                "slug": "stack"
            },
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "72",
        "questionFrontendId": "72",
        "questionTitle": "Edit Distance",
        "translatedTitle": "编辑距离",
        "questionTitleSlug": "edit-distance",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"89K\", \"totalSubmission\": \"148.3K\", \"totalAcceptedRaw\": 88981, \"totalSubmissionRaw\": 148343, \"acRate\": \"60.0%\"}",
        "translatedContent": "<p>给你两个单词&nbsp;<em>word1</em> 和&nbsp;<em>word2</em>，请你计算出将&nbsp;<em>word1</em>&nbsp;转换成&nbsp;<em>word2 </em>所使用的最少操作数&nbsp;。</p>\n\n<p>你可以对一个单词进行如下三种操作：</p>\n\n<ol>\n\t<li>插入一个字符</li>\n\t<li>删除一个字符</li>\n\t<li>替换一个字符</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre><strong>输入：</strong>word1 = &quot;horse&quot;, word2 = &quot;ros&quot;\n<strong>输出：</strong>3\n<strong>解释：</strong>\nhorse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)\nrorse -&gt; rose (删除 &#39;r&#39;)\nrose -&gt; ros (删除 &#39;e&#39;)\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre><strong>输入：</strong>word1 = &quot;intention&quot;, word2 = &quot;execution&quot;\n<strong>输出：</strong>5\n<strong>解释：</strong>\nintention -&gt; inention (删除 &#39;t&#39;)\ninention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)\nenention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)\nexention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)\nexection -&gt; execution (插入 &#39;u&#39;)\n</pre>\n",
        "topicTags": [
            {
                "name": "String",
                "slug": "string"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "73",
        "questionFrontendId": "73",
        "questionTitle": "Set Matrix Zeroes",
        "translatedTitle": "矩阵置零",
        "questionTitleSlug": "set-matrix-zeroes",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"57.2K\", \"totalSubmission\": \"102.5K\", \"totalAcceptedRaw\": 57231, \"totalSubmissionRaw\": 102476, \"acRate\": \"55.8%\"}",
        "translatedContent": "<p>给定一个&nbsp;<em>m</em> x <em>n</em> 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用<strong><a href=\"http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\">原地</a></strong>算法<strong>。</strong></p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> \n[\n&nbsp; [1,1,1],\n&nbsp; [1,0,1],\n&nbsp; [1,1,1]\n]\n<strong>输出:</strong> \n[\n&nbsp; [1,0,1],\n&nbsp; [0,0,0],\n&nbsp; [1,0,1]\n]\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> \n[\n&nbsp; [0,1,2,0],\n&nbsp; [3,4,5,2],\n&nbsp; [1,3,1,5]\n]\n<strong>输出:</strong> \n[\n&nbsp; [0,0,0,0],\n&nbsp; [0,4,5,0],\n&nbsp; [0,3,1,0]\n]</pre>\n\n<p><strong>进阶:</strong></p>\n\n<ul>\n\t<li>一个直接的解决方案是使用 &nbsp;O(<em>m</em><em>n</em>)&nbsp;的额外空间，但这并不是一个好的解决方案。</li>\n\t<li>一个简单的改进方案是使用 O(<em>m</em>&nbsp;+&nbsp;<em>n</em>) 的额外空间，但这仍然不是最好的解决方案。</li>\n\t<li>你能想出一个常数空间的解决方案吗？</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            }
        ]
    },
    {
        "questionId": "74",
        "questionFrontendId": "74",
        "questionTitle": "Search a 2D Matrix",
        "translatedTitle": "搜索二维矩阵",
        "questionTitleSlug": "search-a-2d-matrix",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"66.8K\", \"totalSubmission\": \"170.8K\", \"totalAcceptedRaw\": 66815, \"totalSubmissionRaw\": 170764, \"acRate\": \"39.1%\"}",
        "translatedContent": "<p>编写一个高效的算法来判断 <em>m</em> x <em>n</em> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>\n\n<ul>\n\t<li>每行中的整数从左到右按升序排列。</li>\n\t<li>每行的第一个整数大于前一行的最后一个整数。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/mat.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,50]], target = 3\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,50]], target = 13\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [], target = 0\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>0 <= m, n <= 100</code></li>\n\t<li><code>-10<sup>4</sup> <= matrix[i][j], target <= 10<sup>4</sup></code></li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Binary Search",
                "slug": "binary-search"
            }
        ]
    },
    {
        "questionId": "75",
        "questionFrontendId": "75",
        "questionTitle": "Sort Colors",
        "translatedTitle": "颜色分类",
        "questionTitleSlug": "sort-colors",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"144.6K\", \"totalSubmission\": \"254.6K\", \"totalAcceptedRaw\": 144553, \"totalSubmissionRaw\": 254553, \"acRate\": \"56.8%\"}",
        "translatedContent": "<p>给定一个包含红色、白色和蓝色，一共&nbsp;<em>n </em>个元素的数组，<strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\">原地</a></strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>\n\n<p>此题中，我们使用整数 0、&nbsp;1 和 2 分别表示红色、白色和蓝色。</p>\n\n<p><strong>注意:</strong><br>\n不能使用代码库中的排序函数来解决这道题。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> [2,0,2,1,1,0]\n<strong>输出:</strong> [0,0,1,1,2,2]</pre>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>\n\t首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li>\n\t<li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Sort",
                "slug": "sort"
            },
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            }
        ]
    },
    {
        "questionId": "76",
        "questionFrontendId": "76",
        "questionTitle": "Minimum Window Substring",
        "translatedTitle": "最小覆盖子串",
        "questionTitleSlug": "minimum-window-substring",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"84.5K\", \"totalSubmission\": \"214.3K\", \"totalAcceptedRaw\": 84485, \"totalSubmissionRaw\": 214288, \"acRate\": \"39.4%\"}",
        "translatedContent": "<p>给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：S</strong> = &quot;ADOBECODEBANC&quot;, <strong>T</strong> = &quot;ABC&quot;\n<strong>输出：</strong>&quot;BANC&quot;</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>如果 S 中不存这样的子串，则返回空字符串 <code>&quot;&quot;</code>。</li>\n\t<li>如果 S 中存在这样的子串，我们保证它是唯一的答案。</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Hash Table",
                "slug": "hash-table"
            },
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            },
            {
                "name": "String",
                "slug": "string"
            },
            {
                "name": "Sliding Window",
                "slug": "sliding-window"
            }
        ]
    },
    {
        "questionId": "77",
        "questionFrontendId": "77",
        "questionTitle": "Combinations",
        "translatedTitle": "组合",
        "questionTitleSlug": "combinations",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"110K\", \"totalSubmission\": \"145.2K\", \"totalAcceptedRaw\": 110032, \"totalSubmissionRaw\": 145211, \"acRate\": \"75.8%\"}",
        "translatedContent": "<p>给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 ... <em>n </em>中所有可能的 <em>k</em> 个数的组合。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong>&nbsp;n = 4, k = 2\n<strong>输出:</strong>\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]</pre>\n",
        "topicTags": [
            {
                "name": "Backtracking",
                "slug": "backtracking"
            }
        ]
    },
    {
        "questionId": "78",
        "questionFrontendId": "78",
        "questionTitle": "Subsets",
        "translatedTitle": "子集",
        "questionTitleSlug": "subsets",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"162.5K\", \"totalSubmission\": \"205.4K\", \"totalAcceptedRaw\": 162543, \"totalSubmissionRaw\": 205368, \"acRate\": \"79.1%\"}",
        "translatedContent": "<p>给定一组<strong>不含重复元素</strong>的整数数组&nbsp;<em>nums</em>，返回该数组所有可能的子集（幂集）。</p>\n\n<p><strong>说明：</strong>解集不能包含重复的子集。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> nums = [1,2,3]\n<strong>输出:</strong>\n[\n  [3],\n&nbsp; [1],\n&nbsp; [2],\n&nbsp; [1,2,3],\n&nbsp; [1,3],\n&nbsp; [2,3],\n&nbsp; [1,2],\n&nbsp; []\n]</pre>\n",
        "topicTags": [
            {
                "name": "Bit Manipulation",
                "slug": "bit-manipulation"
            },
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Backtracking",
                "slug": "backtracking"
            }
        ]
    },
    {
        "questionId": "79",
        "questionFrontendId": "79",
        "questionTitle": "Word Search",
        "translatedTitle": "单词搜索",
        "questionTitleSlug": "word-search",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"115.1K\", \"totalSubmission\": \"263.8K\", \"totalAcceptedRaw\": 115140, \"totalSubmissionRaw\": 263825, \"acRate\": \"43.6%\"}",
        "translatedContent": "<p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>\n\n<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中&ldquo;相邻&rdquo;单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>board =\n[\n  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],\n  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],\n  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]\n]\n\n给定 word = &quot;<strong>ABCCED</strong>&quot;, 返回 <strong>true</strong>\n给定 word = &quot;<strong>SEE</strong>&quot;, 返回 <strong>true</strong>\n给定 word = &quot;<strong>ABCB</strong>&quot;, 返回 <strong>false</strong></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>board</code> 和 <code>word</code> 中只包含大写和小写英文字母。</li>\n\t<li><code>1 &lt;= board.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= board[i].length &lt;= 200</code></li>\n\t<li><code>1 &lt;= word.length &lt;= 10^3</code></li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Backtracking",
                "slug": "backtracking"
            }
        ]
    },
    {
        "questionId": "80",
        "questionFrontendId": "80",
        "questionTitle": "Remove Duplicates from Sorted Array II",
        "translatedTitle": "删除排序数组中的重复项 II",
        "questionTitleSlug": "remove-duplicates-from-sorted-array-ii",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"62.4K\", \"totalSubmission\": \"110.6K\", \"totalAcceptedRaw\": 62449, \"totalSubmissionRaw\": 110579, \"acRate\": \"56.5%\"}",
        "translatedContent": "<p>给定一个排序数组，你需要在<strong><a href=\"http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\">原地</a></strong>删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p>\n\n<p>不要使用额外的数组空间，你必须在<strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\">原地</a>修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>给定 <em>nums</em> = <strong>[1,1,1,2,2,3]</strong>,\n\n函数应返回新长度 length = <strong><code>5</code></strong>, 并且原数组的前五个元素被修改为 <strong><code>1, 1, 2, 2,</code></strong> <strong>3 </strong>。\n\n你不需要考虑数组中超出新长度后面的元素。</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>给定 <em>nums</em> = <strong>[0,0,1,1,1,1,2,3,3]</strong>,\n\n函数应返回新长度 length = <strong><code>7</code></strong>, 并且原数组的前五个元素被修改为&nbsp;<strong><code>0</code></strong>, <strong>0</strong>, <strong>1</strong>, <strong>1</strong>, <strong>2</strong>, <strong>3</strong>, <strong>3 。</strong>\n\n你不需要考虑数组中超出新长度后面的元素。\n</pre>\n\n<p><strong>说明:</strong></p>\n\n<p>为什么返回数值是整数，但输出的答案是数组呢?</p>\n\n<p>请注意，输入数组是以<strong>&ldquo;引用&rdquo;</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>\n\n<p>你可以想象内部操作如下:</p>\n\n<pre>// <strong>nums</strong> 是以&ldquo;引用&rdquo;方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中<strong>该长度范围内</strong>的所有元素。\nfor (int i = 0; i &lt; len; i++) {\n&nbsp; &nbsp; print(nums[i]);\n}</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            }
        ]
    },
    {
        "questionId": "81",
        "questionFrontendId": "81",
        "questionTitle": "Search in Rotated Sorted Array II",
        "translatedTitle": "搜索旋转排序数组 II",
        "questionTitleSlug": "search-in-rotated-sorted-array-ii",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"42.6K\", \"totalSubmission\": \"118.2K\", \"totalAcceptedRaw\": 42553, \"totalSubmissionRaw\": 118231, \"acRate\": \"36.0%\"}",
        "translatedContent": "<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>\n\n<p>( 例如，数组&nbsp;<code>[0,0,1,2,2,5,6]</code>&nbsp;可能变为&nbsp;<code>[2,5,6,0,0,1,2]</code>&nbsp;)。</p>\n\n<p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回&nbsp;<code>true</code>，否则返回&nbsp;<code>false</code>。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> nums = [2<code>,5,6,0,0,1,2]</code>, target = 0\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> nums = [2<code>,5,6,0,0,1,2]</code>, target = 3\n<strong>输出:</strong> false</pre>\n\n<p><strong>进阶:</strong></p>\n\n<ul>\n\t<li>这是 <a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/\">搜索旋转排序数组</a>&nbsp;的延伸题目，本题中的&nbsp;<code>nums</code>&nbsp; 可能包含重复元素。</li>\n\t<li>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Binary Search",
                "slug": "binary-search"
            }
        ]
    },
    {
        "questionId": "82",
        "questionFrontendId": "82",
        "questionTitle": "Remove Duplicates from Sorted List II",
        "translatedTitle": "删除排序链表中的重复元素 II",
        "questionTitleSlug": "remove-duplicates-from-sorted-list-ii",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"70.2K\", \"totalSubmission\": \"141.8K\", \"totalAcceptedRaw\": 70171, \"totalSubmissionRaw\": 141802, \"acRate\": \"49.5%\"}",
        "translatedContent": "<p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中&nbsp;<em>没有重复出现&nbsp;</em>的数字。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5\n<strong>输出:</strong> 1-&gt;2-&gt;5\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> 1-&gt;1-&gt;1-&gt;2-&gt;3\n<strong>输出:</strong> 2-&gt;3</pre>\n",
        "topicTags": [
            {
                "name": "Linked List",
                "slug": "linked-list"
            }
        ]
    },
    {
        "questionId": "83",
        "questionFrontendId": "83",
        "questionTitle": "Remove Duplicates from Sorted List",
        "translatedTitle": "删除排序链表中的重复元素",
        "questionTitleSlug": "remove-duplicates-from-sorted-list",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"150.9K\", \"totalSubmission\": \"292.5K\", \"totalAcceptedRaw\": 150913, \"totalSubmissionRaw\": 292462, \"acRate\": \"51.6%\"}",
        "translatedContent": "<p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> 1-&gt;1-&gt;2\n<strong>输出:</strong> 1-&gt;2\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;3\n<strong>输出:</strong> 1-&gt;2-&gt;3</pre>\n",
        "topicTags": [
            {
                "name": "Linked List",
                "slug": "linked-list"
            }
        ]
    },
    {
        "questionId": "84",
        "questionFrontendId": "84",
        "questionTitle": "Largest Rectangle in Histogram",
        "translatedTitle": "柱状图中最大的矩形",
        "questionTitleSlug": "largest-rectangle-in-histogram",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"95K\", \"totalSubmission\": \"227K\", \"totalAcceptedRaw\": 94983, \"totalSubmissionRaw\": 226979, \"acRate\": \"41.8%\"}",
        "translatedContent": "<p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>\n\n<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>\n\n<p>&nbsp;</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png\"></p>\n\n<p><small>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为&nbsp;<code>[2,1,5,6,2,3]</code>。</small></p>\n\n<p>&nbsp;</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png\"></p>\n\n<p><small>图中阴影部分为所能勾勒出的最大矩形面积，其面积为&nbsp;<code>10</code>&nbsp;个单位。</small></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> [2,1,5,6,2,3]\n<strong>输出:</strong> 10</pre>\n",
        "topicTags": [
            {
                "name": "Stack",
                "slug": "stack"
            },
            {
                "name": "Array",
                "slug": "array"
            }
        ]
    },
    {
        "questionId": "85",
        "questionFrontendId": "85",
        "questionTitle": "Maximal Rectangle",
        "translatedTitle": "最大矩形",
        "questionTitleSlug": "maximal-rectangle",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"44.5K\", \"totalSubmission\": \"92K\", \"totalAcceptedRaw\": 44466, \"totalSubmissionRaw\": 92015, \"acRate\": \"48.3%\"}",
        "translatedContent": "<p>给定一个仅包含&nbsp;0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong>\n[\n  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;0&quot;,&quot;<strong>1</strong>&quot;,&quot;<strong>1</strong>&quot;,&quot;<strong>1</strong>&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;<strong>1</strong>&quot;,&quot;<strong>1</strong>&quot;,&quot;<strong>1</strong>&quot;],\n  [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]\n]\n<strong>输出:</strong> 6</pre>\n",
        "topicTags": [
            {
                "name": "Stack",
                "slug": "stack"
            },
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Hash Table",
                "slug": "hash-table"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "86",
        "questionFrontendId": "86",
        "questionTitle": "Partition List",
        "translatedTitle": "分隔链表",
        "questionTitleSlug": "partition-list",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"56K\", \"totalSubmission\": \"93.4K\", \"totalAcceptedRaw\": 55971, \"totalSubmissionRaw\": 93379, \"acRate\": \"59.9%\"}",
        "translatedContent": "<p>给定一个链表和一个特定值<em> x</em>，对链表进行分隔，使得所有小于 <em>x</em> 的节点都在大于或等于 <em>x</em> 的节点之前。</p>\n\n<p>你应当保留两个分区中每个节点的初始相对位置。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, <em>x</em> = 3\n<strong>输出:</strong> 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5\n</pre>\n",
        "topicTags": [
            {
                "name": "Linked List",
                "slug": "linked-list"
            },
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            }
        ]
    },
    {
        "questionId": "87",
        "questionFrontendId": "87",
        "questionTitle": "Scramble String",
        "translatedTitle": "扰乱字符串",
        "questionTitleSlug": "scramble-string",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"14.2K\", \"totalSubmission\": \"29.6K\", \"totalAcceptedRaw\": 14230, \"totalSubmissionRaw\": 29604, \"acRate\": \"48.1%\"}",
        "translatedContent": "<p>给定一个字符串&nbsp;<em>s1</em>，我们可以把它递归地分割成两个非空子字符串，从而将其表示为二叉树。</p>\n\n<p>下图是字符串&nbsp;<em>s1</em>&nbsp;=&nbsp;<code>&quot;great&quot;</code>&nbsp;的一种可能的表示形式。</p>\n\n<pre>    great\n   /    \\\n  gr    eat\n / \\    /  \\\ng   r  e   at\n           / \\\n          a   t\n</pre>\n\n<p>在扰乱这个字符串的过程中，我们可以挑选任何一个非叶节点，然后交换它的两个子节点。</p>\n\n<p>例如，如果我们挑选非叶节点&nbsp;<code>&quot;gr&quot;</code>&nbsp;，交换它的两个子节点，将会产生扰乱字符串&nbsp;<code>&quot;rgeat&quot;</code>&nbsp;。</p>\n\n<pre>    rgeat\n   /    \\\n  rg    eat\n / \\    /  \\\nr   g  e   at\n           / \\\n          a   t\n</pre>\n\n<p>我们将&nbsp;<code>&quot;rgeat&rdquo;</code>&nbsp;称作&nbsp;<code>&quot;great&quot;</code>&nbsp;的一个扰乱字符串。</p>\n\n<p>同样地，如果我们继续交换节点&nbsp;<code>&quot;eat&quot;</code>&nbsp;和&nbsp;<code>&quot;at&quot;</code>&nbsp;的子节点，将会产生另一个新的扰乱字符串&nbsp;<code>&quot;rgtae&quot;</code>&nbsp;。</p>\n\n<pre>    rgtae\n   /    \\\n  rg    tae\n / \\    /  \\\nr   g  ta  e\n       / \\\n      t   a\n</pre>\n\n<p>我们将&nbsp;<code>&quot;rgtae&rdquo;</code>&nbsp;称作&nbsp;<code>&quot;great&quot;</code>&nbsp;的一个扰乱字符串。</p>\n\n<p>给出两个长度相等的字符串 <em>s1 </em>和&nbsp;<em>s2</em>，判断&nbsp;<em>s2&nbsp;</em>是否是&nbsp;<em>s1&nbsp;</em>的扰乱字符串。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;\n<strong>输出:</strong> false</pre>\n",
        "topicTags": [
            {
                "name": "String",
                "slug": "string"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "88",
        "questionFrontendId": "88",
        "questionTitle": "Merge Sorted Array",
        "translatedTitle": "合并两个有序数组",
        "questionTitleSlug": "merge-sorted-array",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"220.8K\", \"totalSubmission\": \"452.5K\", \"totalAcceptedRaw\": 220796, \"totalSubmissionRaw\": 452478, \"acRate\": \"48.8%\"}",
        "translatedContent": "<p>给你两个有序整数数组 <em>nums1 </em>和 <em>nums2</em>，请你将 <em>nums2 </em>合并到 <em>nums1 </em>中<em>，</em>使 <em>nums1 </em>成为一个有序数组。</p>\n\n<p> </p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>初始化 <em>nums1</em> 和 <em>nums2</em> 的元素数量分别为 <em>m</em> 和 <em>n </em>。</li>\n\t<li>你可以假设 <em>nums1 </em>有足够的空间（空间大小大于或等于 <em>m + n</em>）来保存 <em>nums2</em> 中的元素。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nnums1 = [1,2,3,0,0,0], m = 3\nnums2 = [2,5,6],       n = 3\n\n<strong>输出：</strong>[1,2,2,3,5,6]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-10^9 <= nums1[i], nums2[i] <= 10^9</code></li>\n\t<li><code>nums1.length == m + n</code></li>\n\t<li><code>nums2.length == n</code></li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            }
        ]
    },
    {
        "questionId": "89",
        "questionFrontendId": "89",
        "questionTitle": "Gray Code",
        "translatedTitle": "格雷编码",
        "questionTitleSlug": "gray-code",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"35.5K\", \"totalSubmission\": \"51.3K\", \"totalAcceptedRaw\": 35453, \"totalSubmissionRaw\": 51305, \"acRate\": \"69.1%\"}",
        "translatedContent": "<p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p>\n\n<p>给定一个代表编码总位数的非负整数<em> n</em>，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。</p>\n\n<p>格雷编码序列必须以 0 开头。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong>&nbsp;2\n<strong>输出:</strong>&nbsp;<code>[0,1,3,2]</code>\n<strong>解释:</strong>\n00 - 0\n01 - 1\n11 - 3\n10 - 2\n\n对于给定的&nbsp;<em>n</em>，其格雷编码序列并不唯一。\n例如，<code>[0,2,3,1]</code>&nbsp;也是一个有效的格雷编码序列。\n\n00 - 0\n10 - 2\n11 - 3\n01 - 1</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong>&nbsp;0\n<strong>输出:</strong>&nbsp;<code>[0]\n<strong>解释:</strong> 我们定义</code>格雷编码序列必须以 0 开头。<code>\n&nbsp;    给定</code>编码总位数为<code> <em>n</em> 的格雷编码序列，其长度为 2<sup>n</sup></code>。<code>当 <em>n</em> = 0 时，长度为 2<sup>0</sup> = 1。\n&nbsp;    因此，当 <em>n</em> = 0 时，其格雷编码序列为 [0]。</code>\n</pre>\n",
        "topicTags": [
            {
                "name": "Backtracking",
                "slug": "backtracking"
            }
        ]
    },
    {
        "questionId": "90",
        "questionFrontendId": "90",
        "questionTitle": "Subsets II",
        "translatedTitle": "子集 II",
        "questionTitleSlug": "subsets-ii",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"53.6K\", \"totalSubmission\": \"87.4K\", \"totalAcceptedRaw\": 53553, \"totalSubmissionRaw\": 87431, \"acRate\": \"61.3%\"}",
        "translatedContent": "<p>给定一个可能包含重复元素的整数数组 <em><strong>nums</strong></em>，返回该数组所有可能的子集（幂集）。</p>\n\n<p><strong>说明：</strong>解集不能包含重复的子集。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> [1,2,2]\n<strong>输出:</strong>\n[\n  [2],\n  [1],\n  [1,2,2],\n  [2,2],\n  [1,2],\n  []\n]</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Backtracking",
                "slug": "backtracking"
            }
        ]
    },
    {
        "questionId": "91",
        "questionFrontendId": "91",
        "questionTitle": "Decode Ways",
        "translatedTitle": "解码方法",
        "questionTitleSlug": "decode-ways",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"71.6K\", \"totalSubmission\": \"290.1K\", \"totalAcceptedRaw\": 71585, \"totalSubmissionRaw\": 290123, \"acRate\": \"24.7%\"}",
        "translatedContent": "<p>一条包含字母&nbsp;<code>A-Z</code> 的消息通过以下方式进行了编码：</p>\n\n<pre>&#39;A&#39; -&gt; 1\n&#39;B&#39; -&gt; 2\n...\n&#39;Z&#39; -&gt; 26\n</pre>\n\n<p>给定一个只包含数字的<strong>非空</strong>字符串，请计算解码方法的总数。</p>\n\n<p>题目数据保证答案肯定是一个 32 位的整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>&quot;12&quot;\n<strong>输出：</strong>2\n<strong>解释：</strong>它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>&quot;226&quot;\n<strong>输出：</strong>3\n<strong>解释：</strong>它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;0&quot;\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1&quot;\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;2&quot;\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 只包含数字，并且可以包含前导零。</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "String",
                "slug": "string"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "92",
        "questionFrontendId": "92",
        "questionTitle": "Reverse Linked List II",
        "translatedTitle": "反转链表 II",
        "questionTitleSlug": "reverse-linked-list-ii",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"80.9K\", \"totalSubmission\": \"156.7K\", \"totalAcceptedRaw\": 80891, \"totalSubmissionRaw\": 156731, \"acRate\": \"51.6%\"}",
        "translatedContent": "<p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转。</p>\n\n<p><strong>说明:</strong><br>\n1 &le;&nbsp;<em>m</em>&nbsp;&le;&nbsp;<em>n</em>&nbsp;&le; 链表长度。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, <em>m</em> = 2, <em>n</em> = 4\n<strong>输出:</strong> 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</pre>\n",
        "topicTags": [
            {
                "name": "Linked List",
                "slug": "linked-list"
            }
        ]
    },
    {
        "questionId": "93",
        "questionFrontendId": "93",
        "questionTitle": "Restore IP Addresses",
        "translatedTitle": "复原IP地址",
        "questionTitleSlug": "restore-ip-addresses",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"85K\", \"totalSubmission\": \"168.9K\", \"totalAcceptedRaw\": 84961, \"totalSubmissionRaw\": 168879, \"acRate\": \"50.3%\"}",
        "translatedContent": "<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>\n\n<p><strong>有效的 IP 地址</strong> 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39; </code>分隔。</p>\n\n<p>例如：&quot;0.1.2.201&quot; 和 &quot;192.168.1.1&quot; 是 <strong>有效的</strong> IP 地址，但是 &quot;0.011.255.245&quot;、&quot;192.168.1.312&quot; 和 &quot;192.168@1.1&quot; 是 <strong>无效的</strong> IP 地址。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;25525511135&quot;\n<strong>输出：</strong>[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;0000&quot;\n<strong>输出：</strong>[&quot;0.0.0.0&quot;]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1111&quot;\n<strong>输出：</strong>[&quot;1.1.1.1&quot;]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;010010&quot;\n<strong>输出：</strong>[&quot;0.10.0.10&quot;,&quot;0.100.1.0&quot;]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;101023&quot;\n<strong>输出：</strong>[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 3000</code></li>\n\t<li><code>s</code> 仅由数字组成</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "String",
                "slug": "string"
            },
            {
                "name": "Backtracking",
                "slug": "backtracking"
            }
        ]
    },
    {
        "questionId": "94",
        "questionFrontendId": "94",
        "questionTitle": "Binary Tree Inorder Traversal",
        "translatedTitle": "二叉树的中序遍历",
        "questionTitleSlug": "binary-tree-inorder-traversal",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"284.4K\", \"totalSubmission\": \"385K\", \"totalAcceptedRaw\": 284380, \"totalSubmissionRaw\": 385032, \"acRate\": \"73.9%\"}",
        "translatedContent": "<p>给定一个二叉树，返回它的<em>中序&nbsp;</em>遍历。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\n<strong>输出:</strong> [1,3,2]</pre>\n\n<p><strong>进阶:</strong>&nbsp;递归算法很简单，你可以通过迭代算法完成吗？</p>\n",
        "topicTags": [
            {
                "name": "Stack",
                "slug": "stack"
            },
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Hash Table",
                "slug": "hash-table"
            }
        ]
    },
    {
        "questionId": "95",
        "questionFrontendId": "95",
        "questionTitle": "Unique Binary Search Trees II",
        "translatedTitle": "不同的二叉搜索树 II",
        "questionTitleSlug": "unique-binary-search-trees-ii",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"63.7K\", \"totalSubmission\": \"95.5K\", \"totalAcceptedRaw\": 63727, \"totalSubmissionRaw\": 95484, \"acRate\": \"66.7%\"}",
        "translatedContent": "<p>给定一个整数 <em>n</em>，生成所有由 1 ...&nbsp;<em>n</em> 为节点所组成的<strong> 二叉搜索树 </strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>3\n<strong>输出：</strong>\n[\n&nbsp; [1,null,3,2],\n&nbsp; [3,2,null,1],\n&nbsp; [3,1,null,null,2],\n&nbsp; [2,1,3],\n&nbsp; [1,null,2,null,3]\n]\n<strong>解释：</strong>\n以上的输出对应以下 5 种不同结构的二叉搜索树：\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 8</code></li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "96",
        "questionFrontendId": "96",
        "questionTitle": "Unique Binary Search Trees",
        "translatedTitle": "不同的二叉搜索树",
        "questionTitleSlug": "unique-binary-search-trees",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"89.4K\", \"totalSubmission\": \"129.3K\", \"totalAcceptedRaw\": 89427, \"totalSubmissionRaw\": 129327, \"acRate\": \"69.1%\"}",
        "translatedContent": "<p>给定一个整数 <em>n</em>，求以&nbsp;1 ...&nbsp;<em>n</em>&nbsp;为节点组成的二叉搜索树有多少种？</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> 3\n<strong>输出:</strong> 5\n<strong>解释:\n</strong>给定 <em>n</em> = 3, 一共有 5 种不同结构的二叉搜索树:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3</pre>\n",
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "97",
        "questionFrontendId": "97",
        "questionTitle": "Interleaving String",
        "translatedTitle": "交错字符串",
        "questionTitleSlug": "interleaving-string",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"37.1K\", \"totalSubmission\": \"81.7K\", \"totalAcceptedRaw\": 37079, \"totalSubmissionRaw\": 81669, \"acRate\": \"45.4%\"}",
        "translatedContent": "<p>给定三个字符串 <code>s1</code>、<code>s2</code>、<code>s3</code>，请你帮忙验证 <code>s3</code> 是否是由 <code>s1</code> 和 <code>s2</code><em> </em><strong>交错 </strong>组成的。</p>\n\n<p>两个字符串 <code>s</code> 和 <code>t</code> <strong>交错</strong> 的定义与过程如下，其中每个字符串都会被分割成若干 <strong>非空</strong> 子字符串：</p>\n\n<ul>\n\t<li><code>s = s<sub>1</sub> + s<sub>2</sub> + ... + s<sub>n</sub></code></li>\n\t<li><code>t = t<sub>1</sub> + t<sub>2</sub> + ... + t<sub>m</sub></code></li>\n\t<li><code>|n - m| <= 1</code></li>\n\t<li><strong>交错</strong> 是 <code>s<sub>1</sub> + t<sub>1</sub> + s<sub>2</sub> + t<sub>2</sub> + s<sub>3</sub> + t<sub>3</sub> + ...</code> 或者 <code>t<sub>1</sub> + s<sub>1</sub> + t<sub>2</sub> + s<sub>2</sub> + t<sub>3</sub> + s<sub>3</sub> + ...</code></li>\n</ul>\n\n<p><strong>提示：</strong><code>a + b</code> 意味着字符串 <code>a</code> 和 <code>b</code> 连接。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg\" style=\"width: 561px; height: 203px;\" />\n<pre>\n<strong>输入：</strong>s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"\", s2 = \"\", s3 = \"\"\n<strong>输出：</strong>true\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= s1.length, s2.length <= 100</code></li>\n\t<li><code>0 <= s3.length <= 200</code></li>\n\t<li><code>s1</code>、<code>s2</code>、和 <code>s3</code> 都由小写英文字母组成</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "String",
                "slug": "string"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "98",
        "questionFrontendId": "98",
        "questionTitle": "Validate Binary Search Tree",
        "translatedTitle": "验证二叉搜索树",
        "questionTitleSlug": "validate-binary-search-tree",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"181.9K\", \"totalSubmission\": \"557.8K\", \"totalAcceptedRaw\": 181853, \"totalSubmissionRaw\": 557806, \"acRate\": \"32.6%\"}",
        "translatedContent": "<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>\n\n<p>假设一个二叉搜索树具有如下特征：</p>\n\n<ul>\n\t<li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li>\n\t<li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li>\n\t<li>所有左子树和右子树自身必须也是二叉搜索树。</li>\n</ul>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong>\n    2\n   / \\\n  1   3\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:\n</strong>    5\n   / \\\n  1   4\n&nbsp;    / \\\n&nbsp;   3   6\n<strong>输出:</strong> false\n<strong>解释:</strong> 输入为: [5,1,4,null,null,3,6]。\n&nbsp;    根节点的值为 5 ，但是其右子节点值为 4 。\n</pre>\n",
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            }
        ]
    },
    {
        "questionId": "99",
        "questionFrontendId": "99",
        "questionTitle": "Recover Binary Search Tree",
        "translatedTitle": "恢复二叉搜索树",
        "questionTitleSlug": "recover-binary-search-tree",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"41K\", \"totalSubmission\": \"66.2K\", \"totalAcceptedRaw\": 41019, \"totalSubmissionRaw\": 66204, \"acRate\": \"62.0%\"}",
        "translatedContent": "<p>二叉搜索树中的两个节点被错误地交换。</p>\n\n<p>请在不改变其结构的情况下，恢复这棵树。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> [1,3,null,null,2]\n\n&nbsp;  1\n&nbsp; /\n&nbsp;3\n&nbsp; \\\n&nbsp;  2\n\n<strong>输出:</strong> [3,1,null,null,2]\n\n&nbsp;  3\n&nbsp; /\n&nbsp;1\n&nbsp; \\\n&nbsp;  2\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> [3,1,4,null,null,2]\n\n  3\n / \\\n1   4\n&nbsp;  /\n&nbsp; 2\n\n<strong>输出:</strong> [2,1,4,null,null,3]\n\n  2\n / \\\n1   4\n&nbsp;  /\n &nbsp;3</pre>\n\n<p><strong>进阶:</strong></p>\n\n<ul>\n\t<li>使用 O(<em>n</em>) 空间复杂度的解法很容易实现。</li>\n\t<li>你能想出一个只使用常数空间的解决方案吗？</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            }
        ]
    },
    {
        "questionId": "100",
        "questionFrontendId": "100",
        "questionTitle": "Same Tree",
        "translatedTitle": "相同的树",
        "questionTitleSlug": "same-tree",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"148.6K\", \"totalSubmission\": \"246.9K\", \"totalAcceptedRaw\": 148601, \"totalSubmissionRaw\": 246860, \"acRate\": \"60.2%\"}",
        "translatedContent": "<p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>\n\n<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入: </strong>      1         1\n          / \\       / \\\n         2   3     2   3\n\n        [1,2,3],   [1,2,3]\n\n<strong>输出:</strong> true</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:  </strong>    1          1\n          /           \\\n         2             2\n\n        [1,2],     [1,null,2]\n\n<strong>输出:</strong> false\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre><strong>输入:</strong>       1         1\n          / \\       / \\\n         2   1     1   2\n\n        [1,2,1],   [1,1,2]\n\n<strong>输出:</strong> false\n</pre>\n",
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            }
        ]
    },
    {
        "questionId": "101",
        "questionFrontendId": "101",
        "questionTitle": "Symmetric Tree",
        "translatedTitle": "对称二叉树",
        "questionTitleSlug": "symmetric-tree",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"219.9K\", \"totalSubmission\": \"414.3K\", \"totalAcceptedRaw\": 219887, \"totalSubmissionRaw\": 414269, \"acRate\": \"53.1%\"}",
        "translatedContent": "<p>给定一个二叉树，检查它是否是镜像对称的。</p>\n\n<p>&nbsp;</p>\n\n<p>例如，二叉树&nbsp;<code>[1,2,2,3,4,4,3]</code> 是对称的。</p>\n\n<pre>    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n</pre>\n\n<p>&nbsp;</p>\n\n<p>但是下面这个&nbsp;<code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>\n\n<pre>    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你可以运用递归和迭代两种方法解决这个问题吗？</p>\n",
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            },
            {
                "name": "Breadth-first Search",
                "slug": "breadth-first-search"
            }
        ]
    },
    {
        "questionId": "102",
        "questionFrontendId": "102",
        "questionTitle": "Binary Tree Level Order Traversal",
        "translatedTitle": "二叉树的层序遍历",
        "questionTitleSlug": "binary-tree-level-order-traversal",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"207.1K\", \"totalSubmission\": \"325.9K\", \"totalAcceptedRaw\": 207120, \"totalSubmissionRaw\": 325890, \"acRate\": \"63.6%\"}",
        "translatedContent": "<p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong><br>\n二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>\n\n<pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</pre>\n\n<p>返回其层次遍历结果：</p>\n\n<pre>[\n  [3],\n  [9,20],\n  [15,7]\n]\n</pre>\n",
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Breadth-first Search",
                "slug": "breadth-first-search"
            }
        ]
    },
    {
        "questionId": "103",
        "questionFrontendId": "103",
        "questionTitle": "Binary Tree Zigzag Level Order Traversal",
        "translatedTitle": "二叉树的锯齿形层次遍历",
        "questionTitleSlug": "binary-tree-zigzag-level-order-traversal",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"75.6K\", \"totalSubmission\": \"137.2K\", \"totalAcceptedRaw\": 75620, \"totalSubmissionRaw\": 137217, \"acRate\": \"55.1%\"}",
        "translatedContent": "<p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>\n\n<p>例如：<br>\n给定二叉树&nbsp;<code>[3,9,20,null,null,15,7]</code>,</p>\n\n<pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</pre>\n\n<p>返回锯齿形层次遍历如下：</p>\n\n<pre>[\n  [3],\n  [20,9],\n  [15,7]\n]\n</pre>\n",
        "topicTags": [
            {
                "name": "Stack",
                "slug": "stack"
            },
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Breadth-first Search",
                "slug": "breadth-first-search"
            }
        ]
    },
    {
        "questionId": "104",
        "questionFrontendId": "104",
        "questionTitle": "Maximum Depth of Binary Tree",
        "translatedTitle": "二叉树的最大深度",
        "questionTitleSlug": "maximum-depth-of-binary-tree",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"291.5K\", \"totalSubmission\": \"387.7K\", \"totalAcceptedRaw\": 291464, \"totalSubmissionRaw\": 387700, \"acRate\": \"75.2%\"}",
        "translatedContent": "<p>给定一个二叉树，找出其最大深度。</p>\n\n<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>\n\n<p><strong>说明:</strong>&nbsp;叶子节点是指没有子节点的节点。</p>\n\n<p><strong>示例：</strong><br>\n给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>\n\n<pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7</pre>\n\n<p>返回它的最大深度&nbsp;3 。</p>\n",
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            }
        ]
    },
    {
        "questionId": "105",
        "questionFrontendId": "105",
        "questionTitle": "Construct Binary Tree from Preorder and Inorder Traversal",
        "translatedTitle": "从前序与中序遍历序列构造二叉树",
        "questionTitleSlug": "construct-binary-tree-from-preorder-and-inorder-traversal",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"122.7K\", \"totalSubmission\": \"179.6K\", \"totalAcceptedRaw\": 122693, \"totalSubmissionRaw\": 179570, \"acRate\": \"68.3%\"}",
        "translatedContent": "<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>\n\n<p><strong>注意:</strong><br>\n你可以假设树中没有重复的元素。</p>\n\n<p>例如，给出</p>\n\n<pre>前序遍历 preorder =&nbsp;[3,9,20,15,7]\n中序遍历 inorder = [9,3,15,20,7]</pre>\n\n<p>返回如下的二叉树：</p>\n\n<pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7</pre>\n",
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            },
            {
                "name": "Array",
                "slug": "array"
            }
        ]
    },
    {
        "questionId": "106",
        "questionFrontendId": "106",
        "questionTitle": "Construct Binary Tree from Inorder and Postorder Traversal",
        "translatedTitle": "从中序与后序遍历序列构造二叉树",
        "questionTitleSlug": "construct-binary-tree-from-inorder-and-postorder-traversal",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"74.1K\", \"totalSubmission\": \"104.8K\", \"totalAcceptedRaw\": 74052, \"totalSubmissionRaw\": 104786, \"acRate\": \"70.7%\"}",
        "translatedContent": "<p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>\n\n<p><strong>注意:</strong><br>\n你可以假设树中没有重复的元素。</p>\n\n<p>例如，给出</p>\n\n<pre>中序遍历 inorder =&nbsp;[9,3,15,20,7]\n后序遍历 postorder = [9,15,7,20,3]</pre>\n\n<p>返回如下的二叉树：</p>\n\n<pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</pre>\n",
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            },
            {
                "name": "Array",
                "slug": "array"
            }
        ]
    },
    {
        "questionId": "107",
        "questionFrontendId": "107",
        "questionTitle": "Binary Tree Level Order Traversal II",
        "translatedTitle": "二叉树的层次遍历 II",
        "questionTitleSlug": "binary-tree-level-order-traversal-ii",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"105.1K\", \"totalSubmission\": \"155.4K\", \"totalAcceptedRaw\": 105140, \"totalSubmissionRaw\": 155388, \"acRate\": \"67.7%\"}",
        "translatedContent": "<p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>\n\n<p>例如：<br>\n给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>\n\n<pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</pre>\n\n<p>返回其自底向上的层次遍历为：</p>\n\n<pre>[\n  [15,7],\n  [9,20],\n  [3]\n]\n</pre>\n",
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Breadth-first Search",
                "slug": "breadth-first-search"
            }
        ]
    },
    {
        "questionId": "108",
        "questionFrontendId": "108",
        "questionTitle": "Convert Sorted Array to Binary Search Tree",
        "translatedTitle": "将有序数组转换为二叉搜索树",
        "questionTitleSlug": "convert-sorted-array-to-binary-search-tree",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"119.9K\", \"totalSubmission\": \"161.3K\", \"totalAcceptedRaw\": 119873, \"totalSubmissionRaw\": 161347, \"acRate\": \"74.3%\"}",
        "translatedContent": "<p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>\n\n<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点&nbsp;</em>的左右两个子树的高度差的绝对值不超过 1。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>给定有序数组: [-10,-3,0,5,9],\n\n一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n</pre>\n",
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            }
        ]
    },
    {
        "questionId": "109",
        "questionFrontendId": "109",
        "questionTitle": "Convert Sorted List to Binary Search Tree",
        "translatedTitle": "有序链表转换二叉搜索树",
        "questionTitleSlug": "convert-sorted-list-to-binary-search-tree",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"63.2K\", \"totalSubmission\": \"83.1K\", \"totalAcceptedRaw\": 63213, \"totalSubmissionRaw\": 83131, \"acRate\": \"76.0%\"}",
        "translatedContent": "<p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>\n\n<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点&nbsp;</em>的左右两个子树的高度差的绝对值不超过 1。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>给定的有序链表： [-10, -3, 0, 5, 9],\n\n一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n</pre>\n",
        "topicTags": [
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            },
            {
                "name": "Linked List",
                "slug": "linked-list"
            }
        ]
    },
    {
        "questionId": "110",
        "questionFrontendId": "110",
        "questionTitle": "Balanced Binary Tree",
        "translatedTitle": "平衡二叉树",
        "questionTitleSlug": "balanced-binary-tree",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"143K\", \"totalSubmission\": \"261.2K\", \"totalAcceptedRaw\": 142989, \"totalSubmissionRaw\": 261190, \"acRate\": \"54.7%\"}",
        "translatedContent": "<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>\n\n<p>本题中，一棵高度平衡二叉树定义为：</p>\n\n<blockquote>\n<p>一个二叉树<em>每个节点&nbsp;</em>的左右两个子树的高度差的绝对值不超过1。</p>\n</blockquote>\n\n<p><strong>示例 1:</strong></p>\n\n<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p>\n\n<pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7</pre>\n\n<p>返回 <code>true</code> 。<br>\n<br>\n<strong>示例 2:</strong></p>\n\n<p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p>\n\n<pre>       1\n      / \\\n     2   2\n    / \\\n   3   3\n  / \\\n 4   4\n</pre>\n\n<p>返回&nbsp;<code>false</code> 。</p>\n\n<p>&nbsp;</p>\n",
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            }
        ]
    },
    {
        "questionId": "111",
        "questionFrontendId": "111",
        "questionTitle": "Minimum Depth of Binary Tree",
        "translatedTitle": "二叉树的最小深度",
        "questionTitleSlug": "minimum-depth-of-binary-tree",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"143.8K\", \"totalSubmission\": \"322.6K\", \"totalAcceptedRaw\": 143830, \"totalSubmissionRaw\": 322625, \"acRate\": \"44.6%\"}",
        "translatedContent": "<p>给定一个二叉树，找出其最小深度。</p>\n\n<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>\n\n<p><strong>说明:</strong>&nbsp;叶子节点是指没有子节点的节点。</p>\n\n<p><strong>示例:</strong></p>\n\n<p>给定二叉树&nbsp;<code>[3,9,20,null,null,15,7]</code>,</p>\n\n<pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7</pre>\n\n<p>返回它的最小深度 &nbsp;2.</p>\n",
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            },
            {
                "name": "Breadth-first Search",
                "slug": "breadth-first-search"
            }
        ]
    },
    {
        "questionId": "112",
        "questionFrontendId": "112",
        "questionTitle": "Path Sum",
        "translatedTitle": "路径总和",
        "questionTitleSlug": "path-sum",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"144.2K\", \"totalSubmission\": \"281K\", \"totalAcceptedRaw\": 144166, \"totalSubmissionRaw\": 281010, \"acRate\": \"51.3%\"}",
        "translatedContent": "<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>\n\n<p><strong>说明:</strong>&nbsp;叶子节点是指没有子节点的节点。</p>\n\n<p><strong>示例:</strong>&nbsp;<br>\n给定如下二叉树，以及目标和 <code>sum = 22</code>，</p>\n\n<pre>              <strong>5</strong>\n             / \\\n            <strong>4 </strong>  8\n           /   / \\\n          <strong>11 </strong> 13  4\n         /  \\      \\\n        7    <strong>2</strong>      1\n</pre>\n\n<p>返回 <code>true</code>, 因为存在目标和为 22 的根节点到叶子节点的路径 <code>5-&gt;4-&gt;11-&gt;2</code>。</p>\n",
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            }
        ]
    },
    {
        "questionId": "113",
        "questionFrontendId": "113",
        "questionTitle": "Path Sum II",
        "translatedTitle": "路径总和 II",
        "questionTitleSlug": "path-sum-ii",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"98.1K\", \"totalSubmission\": \"160.7K\", \"totalAcceptedRaw\": 98143, \"totalSubmissionRaw\": 160735, \"acRate\": \"61.1%\"}",
        "translatedContent": "<p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>\n\n<p><strong>说明:</strong>&nbsp;叶子节点是指没有子节点的节点。</p>\n\n<p><strong>示例:</strong><br>\n给定如下二叉树，以及目标和&nbsp;<code>sum = 22</code>，</p>\n\n<pre>              <strong>5</strong>\n             / \\\n            <strong>4</strong>   <strong>8</strong>\n           /   / \\\n          <strong>11</strong>  13  <strong>4</strong>\n         /  \\    / \\\n        7    <strong>2</strong>  <strong>5</strong>   1\n</pre>\n\n<p>返回:</p>\n\n<pre>[\n   [5,4,11,2],\n   [5,8,4,5]\n]\n</pre>\n",
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            }
        ]
    },
    {
        "questionId": "114",
        "questionFrontendId": "114",
        "questionTitle": "Flatten Binary Tree to Linked List",
        "translatedTitle": "二叉树展开为链表",
        "questionTitleSlug": "flatten-binary-tree-to-linked-list",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"88K\", \"totalSubmission\": \"123.7K\", \"totalAcceptedRaw\": 88045, \"totalSubmissionRaw\": 123705, \"acRate\": \"71.2%\"}",
        "translatedContent": "<p>给定一个二叉树，<a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/8010757\" target=\"_blank\">原地</a>将它展开为一个单链表。</p>\n\n<p>&nbsp;</p>\n\n<p>例如，给定二叉树</p>\n\n<pre>    1\n   / \\\n  2   5\n / \\   \\\n3   4   6</pre>\n\n<p>将其展开为：</p>\n\n<pre>1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n         \\\n          6</pre>\n",
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            }
        ]
    },
    {
        "questionId": "115",
        "questionFrontendId": "115",
        "questionTitle": "Distinct Subsequences",
        "translatedTitle": "不同的子序列",
        "questionTitleSlug": "distinct-subsequences",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"19.8K\", \"totalSubmission\": \"40.2K\", \"totalAcceptedRaw\": 19779, \"totalSubmissionRaw\": 40190, \"acRate\": \"49.2%\"}",
        "translatedContent": "<p>给定一个字符串&nbsp;<strong>S&nbsp;</strong>和一个字符串&nbsp;<strong>T</strong>，计算在 <strong>S</strong> 的子序列中 <strong>T</strong> 出现的个数。</p>\n\n<p>一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，<code>&quot;ACE&quot;</code>&nbsp;是&nbsp;<code>&quot;ABCDE&quot;</code>&nbsp;的一个子序列，而&nbsp;<code>&quot;AEC&quot;</code>&nbsp;不是）</p>\n\n<p>题目数据保证答案符合 32 位带符号整数范围。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre><strong>输入：</strong>S = <code>&quot;rabbbit&quot;</code>, T = <code>&quot;rabbit&quot;\n<strong>输出</strong></code><strong>：</strong><code>3\n</code><strong>解释：\n</strong>\n如下图所示, 有 3 种可以从 S 中得到 <code>&quot;rabbit&quot; 的方案</code>。\n(上箭头符号 ^ 表示选取的字母)\n\n<code>rabbbit</code>\n^^^^ ^^\n<code>rabbbit</code>\n^^ ^^^^\n<code>rabbbit</code>\n^^^ ^^^\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre><strong>输入：</strong>S = <code>&quot;babgbag&quot;</code>, T = <code>&quot;bag&quot;\n<strong>输出</strong></code><strong>：</strong><code>5\n</code><strong>解释：\n</strong>\n如下图所示, 有 5 种可以从 S 中得到 <code>&quot;bag&quot; 的方案</code>。 \n(上箭头符号 ^ 表示选取的字母)\n\n<code>babgbag</code>\n^^ ^\n<code>babgbag</code>\n^^    ^\n<code>babgbag</code>\n^    ^^\n<code>babgbag</code>\n  ^  ^^\n<code>babgbag</code>\n    ^^^</pre>\n",
        "topicTags": [
            {
                "name": "String",
                "slug": "string"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "116",
        "questionFrontendId": "116",
        "questionTitle": "Populating Next Right Pointers in Each Node",
        "translatedTitle": "填充每个节点的下一个右侧节点指针",
        "questionTitleSlug": "populating-next-right-pointers-in-each-node",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"78.2K\", \"totalSubmission\": \"116K\", \"totalAcceptedRaw\": 78241, \"totalSubmissionRaw\": 115970, \"acRate\": \"67.5%\"}",
        "translatedContent": "<p>给定一个<strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>\n\n<pre>struct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}</pre>\n\n<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p>\n\n<p>初始状态下，所有&nbsp;next 指针都被设置为 <code>NULL</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/116_sample.png\" style=\"height: 218px; width: 640px;\"></p>\n\n<pre><strong>输入：</strong>{&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4},&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5},&quot;val&quot;:2},&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:6},&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7},&quot;val&quot;:3},&quot;val&quot;:1}\n\n<strong>输出：</strong>{&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7},&quot;right&quot;:null,&quot;val&quot;:6},&quot;right&quot;:null,&quot;val&quot;:5},&quot;right&quot;:null,&quot;val&quot;:4},&quot;next&quot;:{&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:{&quot;$ref&quot;:&quot;5&quot;},&quot;next&quot;:null,&quot;right&quot;:{&quot;$ref&quot;:&quot;6&quot;},&quot;val&quot;:3},&quot;right&quot;:{&quot;$ref&quot;:&quot;4&quot;},&quot;val&quot;:2},&quot;next&quot;:null,&quot;right&quot;:{&quot;$ref&quot;:&quot;7&quot;},&quot;val&quot;:1}\n\n<strong>解释：</strong>给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>你只能使用常量级额外空间。</li>\n\t<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            }
        ]
    },
    {
        "questionId": "117",
        "questionFrontendId": "117",
        "questionTitle": "Populating Next Right Pointers in Each Node II",
        "translatedTitle": "填充每个节点的下一个右侧节点指针 II",
        "questionTitleSlug": "populating-next-right-pointers-in-each-node-ii",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"55.1K\", \"totalSubmission\": \"93.5K\", \"totalAcceptedRaw\": 55096, \"totalSubmissionRaw\": 93507, \"acRate\": \"58.9%\"}",
        "translatedContent": "<p>给定一个二叉树</p>\n\n<pre>struct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}</pre>\n\n<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p>\n\n<p>初始状态下，所有&nbsp;next 指针都被设置为 <code>NULL</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你只能使用常量级额外空间。</li>\n\t<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/117_sample.png\" style=\"height: 218px; width: 640px;\"></p>\n\n<pre><strong>输入</strong>：root = [1,2,3,4,5,null,7]\n<strong>输出：</strong>[1,#,2,3,#,4,5,7,#]\n<strong>解释：</strong>给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数小于 <code>6000</code></li>\n\t<li><code>-100&nbsp;&lt;= node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n",
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            }
        ]
    },
    {
        "questionId": "118",
        "questionFrontendId": "118",
        "questionTitle": "Pascal's Triangle",
        "translatedTitle": "杨辉三角",
        "questionTitleSlug": "pascals-triangle",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"111.4K\", \"totalSubmission\": \"164.6K\", \"totalAcceptedRaw\": 111381, \"totalSubmissionRaw\": 164624, \"acRate\": \"67.7%\"}",
        "translatedContent": "<p>给定一个非负整数&nbsp;<em>numRows，</em>生成杨辉三角的前&nbsp;<em>numRows&nbsp;</em>行。</p>\n\n<p><img alt=\"\" src=\"https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif\"></p>\n\n<p><small>在杨辉三角中，每个数是它左上方和右上方的数的和。</small></p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> 5\n<strong>输出:</strong>\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            }
        ]
    },
    {
        "questionId": "119",
        "questionFrontendId": "119",
        "questionTitle": "Pascal's Triangle II",
        "translatedTitle": "杨辉三角 II",
        "questionTitleSlug": "pascals-triangle-ii",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"73.7K\", \"totalSubmission\": \"119K\", \"totalAcceptedRaw\": 73712, \"totalSubmissionRaw\": 119043, \"acRate\": \"61.9%\"}",
        "translatedContent": "<p>给定一个非负索引&nbsp;<em>k</em>，其中 <em>k</em>&nbsp;&le;&nbsp;33，返回杨辉三角的第 <em>k </em>行。</p>\n\n<p><img alt=\"\" src=\"https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif\"></p>\n\n<p><small>在杨辉三角中，每个数是它左上方和右上方的数的和。</small></p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> 3\n<strong>输出:</strong> [1,3,3,1]\n</pre>\n\n<p><strong>进阶：</strong></p>\n\n<p>你可以优化你的算法到 <em>O</em>(<em>k</em>) 空间复杂度吗？</p>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            }
        ]
    },
    {
        "questionId": "120",
        "questionFrontendId": "120",
        "questionTitle": "Triangle",
        "translatedTitle": "三角形最小路径和",
        "questionTitleSlug": "triangle",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"112.6K\", \"totalSubmission\": \"168.7K\", \"totalAcceptedRaw\": 112631, \"totalSubmissionRaw\": 168736, \"acRate\": \"66.7%\"}",
        "translatedContent": "<p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>\n\n<p><strong>相邻的结点 </strong>在这里指的是 <code>下标</code> 与 <code>上一层结点下标</code> 相同或者等于 <code>上一层结点下标 + 1</code> 的两个结点。</p>\n\n<p>&nbsp;</p>\n\n<p>例如，给定三角形：</p>\n\n<pre>[\n     [<strong>2</strong>],\n    [<strong>3</strong>,4],\n   [6,<strong>5</strong>,7],\n  [4,<strong>1</strong>,8,3]\n]\n</pre>\n\n<p>自顶向下的最小路径和为&nbsp;<code>11</code>（即，<strong>2&nbsp;</strong>+&nbsp;<strong>3</strong>&nbsp;+&nbsp;<strong>5&nbsp;</strong>+&nbsp;<strong>1</strong>&nbsp;= 11）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>说明：</strong></p>\n\n<p>如果你可以只使用 <em>O</em>(<em>n</em>)&nbsp;的额外空间（<em>n</em> 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "121",
        "questionFrontendId": "121",
        "questionTitle": "Best Time to Buy and Sell Stock",
        "translatedTitle": "买卖股票的最佳时机",
        "questionTitleSlug": "best-time-to-buy-and-sell-stock",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"301K\", \"totalSubmission\": \"546.8K\", \"totalAcceptedRaw\": 301008, \"totalSubmissionRaw\": 546839, \"acRate\": \"55.0%\"}",
        "translatedContent": "<p>给定一个数组，它的第&nbsp;<em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>\n\n<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>\n\n<p>注意：你不能在买入股票前卖出股票。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> [7,1,5,3,6,4]\n<strong>输出:</strong> 5\n<strong>解释: </strong>在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> [7,6,4,3,1]\n<strong>输出:</strong> 0\n<strong>解释: </strong>在这种情况下, 没有交易完成, 所以最大利润为 0。\n</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "122",
        "questionFrontendId": "122",
        "questionTitle": "Best Time to Buy and Sell Stock II",
        "translatedTitle": "买卖股票的最佳时机 II",
        "questionTitleSlug": "best-time-to-buy-and-sell-stock-ii",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"230.9K\", \"totalSubmission\": \"362.9K\", \"totalAcceptedRaw\": 230929, \"totalSubmissionRaw\": 362938, \"acRate\": \"63.6%\"}",
        "translatedContent": "<p>给定一个数组，它的第&nbsp;<em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>\n\n<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>\n\n<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> [7,1,5,3,6,4]\n<strong>输出:</strong> 7\n<strong>解释:</strong> 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n&nbsp;    随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> [1,2,3,4,5]\n<strong>输出:</strong> 4\n<strong>解释:</strong> 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n&nbsp;    注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。\n&nbsp;    因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre><strong>输入:</strong> [7,6,4,3,1]\n<strong>输出:</strong> 0\n<strong>解释:</strong> 在这种情况下, 没有交易完成, 所以最大利润为 0。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</code></li>\n\t<li><code>0 &lt;= prices[i]&nbsp;&lt;= 10 ^ 4</code></li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Greedy",
                "slug": "greedy"
            },
            {
                "name": "Array",
                "slug": "array"
            }
        ]
    },
    {
        "questionId": "123",
        "questionFrontendId": "123",
        "questionTitle": "Best Time to Buy and Sell Stock III",
        "translatedTitle": "买卖股票的最佳时机 III",
        "questionTitleSlug": "best-time-to-buy-and-sell-stock-iii",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"60.7K\", \"totalSubmission\": \"131.7K\", \"totalAcceptedRaw\": 60715, \"totalSubmissionRaw\": 131716, \"acRate\": \"46.1%\"}",
        "translatedContent": "<p>给定一个数组，它的第<em> i</em> 个元素是一支给定的股票在第 <em>i </em>天的价格。</p>\n\n<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成&nbsp;<em>两笔&nbsp;</em>交易。</p>\n\n<p><strong>注意:</strong>&nbsp;你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> [3,3,5,0,0,3,1,4]\n<strong>输出:</strong> 6\n<strong>解释:</strong> 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。\n&nbsp;    随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> [1,2,3,4,5]\n<strong>输出:</strong> 4\n<strong>解释:</strong> 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 &nbsp; \n&nbsp;    注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 &nbsp; \n&nbsp;    因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre><strong>输入:</strong> [7,6,4,3,1] \n<strong>输出:</strong> 0 \n<strong>解释:</strong> 在这个情况下, 没有交易完成, 所以最大利润为 0。</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "124",
        "questionFrontendId": "124",
        "questionTitle": "Binary Tree Maximum Path Sum",
        "translatedTitle": "二叉树中的最大路径和",
        "questionTitleSlug": "binary-tree-maximum-path-sum",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"80.1K\", \"totalSubmission\": \"185.5K\", \"totalAcceptedRaw\": 80129, \"totalSubmissionRaw\": 185500, \"acRate\": \"43.2%\"}",
        "translatedContent": "<p>给定一个<strong>非空</strong>二叉树，返回其最大路径和。</p>\n\n<p>本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径<strong>至少包含一个</strong>节点，且不一定经过根节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[1,2,3]\n\n       <strong>1</strong>\n      <strong>/ \\</strong>\n     <strong>2</strong>   <strong>3</strong>\n\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre><strong>输入：</strong>[-10,9,20,null,null,15,7]\n\n&nbsp;  -10\n&nbsp; &nbsp;/ \\\n&nbsp; 9 &nbsp;<strong>20</strong>\n&nbsp; &nbsp; <strong>/ &nbsp;\\</strong>\n&nbsp; &nbsp;<strong>15 &nbsp; 7</strong>\n\n<strong>输出：</strong>42</pre>\n",
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            }
        ]
    },
    {
        "questionId": "125",
        "questionFrontendId": "125",
        "questionTitle": "Valid Palindrome",
        "translatedTitle": "验证回文串",
        "questionTitleSlug": "valid-palindrome",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"170.6K\", \"totalSubmission\": \"366.8K\", \"totalAcceptedRaw\": 170601, \"totalSubmissionRaw\": 366813, \"acRate\": \"46.5%\"}",
        "translatedContent": "<p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>\n\n<p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> &quot;A man, a plan, a canal: Panama&quot;\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> &quot;race a car&quot;\n<strong>输出:</strong> false\n</pre>\n",
        "topicTags": [
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            },
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "126",
        "questionFrontendId": "126",
        "questionTitle": "Word Ladder II",
        "translatedTitle": "单词接龙 II",
        "questionTitleSlug": "word-ladder-ii",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"24.6K\", \"totalSubmission\": \"64K\", \"totalAcceptedRaw\": 24643, \"totalSubmissionRaw\": 63991, \"acRate\": \"38.5%\"}",
        "translatedContent": "<p>给定两个单词（<em>beginWord</em> 和 <em>endWord</em>）和一个字典 <em>wordList</em>，找出所有从 <em>beginWord </em>到 <em>endWord </em>的最短转换序列。转换需遵循如下规则：</p>\n\n<ol>\n\t<li>每次转换只能改变一个字母。</li>\n\t<li>转换后得到的单词必须是字典中的单词。</li>\n</ol>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>如果不存在这样的转换序列，返回一个空列表。</li>\n\t<li>所有单词具有相同的长度。</li>\n\t<li>所有单词只由小写字母组成。</li>\n\t<li>字典中不存在重复的单词。</li>\n\t<li>你可以假设 <em>beginWord</em> 和 <em>endWord </em>是非空的，且二者不相同。</li>\n</ul>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong>\nbeginWord = &quot;hit&quot;,\nendWord = &quot;cog&quot;,\nwordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n\n<strong>输出:</strong>\n[\n  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],\n&nbsp; [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong>\nbeginWord = &quot;hit&quot;\nendWord = &quot;cog&quot;\nwordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]\n\n<strong>输出: </strong>[]\n\n<strong>解释:</strong>&nbsp;<em>endWord</em> &quot;cog&quot; 不在字典中，所以不存在符合要求的转换序列。</pre>\n",
        "topicTags": [
            {
                "name": "Breadth-first Search",
                "slug": "breadth-first-search"
            },
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "String",
                "slug": "string"
            },
            {
                "name": "Backtracking",
                "slug": "backtracking"
            }
        ]
    },
    {
        "questionId": "127",
        "questionFrontendId": "127",
        "questionTitle": "Word Ladder",
        "translatedTitle": "单词接龙",
        "questionTitleSlug": "word-ladder",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"64.4K\", \"totalSubmission\": \"146.7K\", \"totalAcceptedRaw\": 64441, \"totalSubmissionRaw\": 146711, \"acRate\": \"43.9%\"}",
        "translatedContent": "<p>给定两个单词（<em>beginWord&nbsp;</em>和 <em>endWord</em>）和一个字典，找到从&nbsp;<em>beginWord</em> 到&nbsp;<em>endWord</em> 的最短转换序列的长度。转换需遵循如下规则：</p>\n\n<ol>\n\t<li>每次转换只能改变一个字母。</li>\n\t<li>转换过程中的中间单词必须是字典中的单词。</li>\n</ol>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>如果不存在这样的转换序列，返回 0。</li>\n\t<li>所有单词具有相同的长度。</li>\n\t<li>所有单词只由小写字母组成。</li>\n\t<li>字典中不存在重复的单词。</li>\n\t<li>你可以假设 <em>beginWord</em> 和 <em>endWord </em>是非空的，且二者不相同。</li>\n</ul>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong>\nbeginWord = &quot;hit&quot;,\nendWord = &quot;cog&quot;,\nwordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n\n<strong>输出: </strong>5\n\n<strong>解释: </strong>一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,\n     返回它的长度 5。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong>\nbeginWord = &quot;hit&quot;\nendWord = &quot;cog&quot;\nwordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]\n\n<strong>输出:</strong>&nbsp;0\n\n<strong>解释:</strong>&nbsp;<em>endWord</em> &quot;cog&quot; 不在字典中，所以无法进行转换。</pre>\n",
        "topicTags": [
            {
                "name": "Breadth-first Search",
                "slug": "breadth-first-search"
            }
        ]
    },
    {
        "questionId": "128",
        "questionFrontendId": "128",
        "questionTitle": "Longest Consecutive Sequence",
        "translatedTitle": "最长连续序列",
        "questionTitleSlug": "longest-consecutive-sequence",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"83.2K\", \"totalSubmission\": \"159.4K\", \"totalAcceptedRaw\": 83243, \"totalSubmissionRaw\": 159382, \"acRate\": \"52.2%\"}",
        "translatedContent": "<p>给定一个未排序的整数数组，找出最长连续序列的长度。</p>\n\n<p>要求算法的时间复杂度为&nbsp;<em>O(n)</em>。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong>&nbsp;[100, 4, 200, 1, 3, 2]\n<strong>输出:</strong> 4\n<strong>解释:</strong> 最长连续序列是 <code>[1, 2, 3, 4]。它的长度为 4。</code></pre>\n",
        "topicTags": [
            {
                "name": "Union Find",
                "slug": "union-find"
            },
            {
                "name": "Array",
                "slug": "array"
            }
        ]
    },
    {
        "questionId": "129",
        "questionFrontendId": "129",
        "questionTitle": "Sum Root to Leaf Numbers",
        "translatedTitle": "求根到叶子节点数字之和",
        "questionTitleSlug": "sum-root-to-leaf-numbers",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"42.5K\", \"totalSubmission\": \"65.5K\", \"totalAcceptedRaw\": 42489, \"totalSubmissionRaw\": 65458, \"acRate\": \"64.9%\"}",
        "translatedContent": "<p>给定一个二叉树，它的每个结点都存放一个&nbsp;<code>0-9</code>&nbsp;的数字，每条从根到叶子节点的路径都代表一个数字。</p>\n\n<p>例如，从根到叶子节点路径 <code>1-&gt;2-&gt;3</code> 代表数字 <code>123</code>。</p>\n\n<p>计算从根到叶子节点生成的所有数字之和。</p>\n\n<p><strong>说明:</strong>&nbsp;叶子节点是指没有子节点的节点。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> [1,2,3]\n    1\n   / \\\n  2   3\n<strong>输出:</strong> 25\n<strong>解释:</strong>\n从根到叶子节点路径 <code>1-&gt;2</code> 代表数字 <code>12</code>.\n从根到叶子节点路径 <code>1-&gt;3</code> 代表数字 <code>13</code>.\n因此，数字总和 = 12 + 13 = <code>25</code>.</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> [4,9,0,5,1]\n    4\n   / \\\n  9   0\n&nbsp;/ \\\n5   1\n<strong>输出:</strong> 1026\n<strong>解释:</strong>\n从根到叶子节点路径 <code>4-&gt;9-&gt;5</code> 代表数字 495.\n从根到叶子节点路径 <code>4-&gt;9-&gt;1</code> 代表数字 491.\n从根到叶子节点路径 <code>4-&gt;0</code> 代表数字 40.\n因此，数字总和 = 495 + 491 + 40 = <code>1026</code>.</pre>\n",
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            }
        ]
    },
    {
        "questionId": "130",
        "questionFrontendId": "130",
        "questionTitle": "Surrounded Regions",
        "translatedTitle": "被围绕的区域",
        "questionTitleSlug": "surrounded-regions",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"75.5K\", \"totalSubmission\": \"178.7K\", \"totalAcceptedRaw\": 75549, \"totalSubmissionRaw\": 178722, \"acRate\": \"42.3%\"}",
        "translatedContent": "<p>给定一个二维的矩阵，包含&nbsp;<code>&#39;X&#39;</code>&nbsp;和&nbsp;<code>&#39;O&#39;</code>（<strong>字母 O</strong>）。</p>\n\n<p>找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的&nbsp;<code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>X X X X\nX O O X\nX X O X\nX O X X\n</pre>\n\n<p>运行你的函数后，矩阵变为：</p>\n\n<pre>X X X X\nX X X X\nX X X X\nX O X X\n</pre>\n\n<p><strong>解释:</strong></p>\n\n<p>被围绕的区间不会存在于边界上，换句话说，任何边界上的&nbsp;<code>&#39;O&#39;</code>&nbsp;都不会被填充为&nbsp;<code>&#39;X&#39;</code>。 任何不在边界上，或不与边界上的&nbsp;<code>&#39;O&#39;</code>&nbsp;相连的&nbsp;<code>&#39;O&#39;</code>&nbsp;最终都会被填充为&nbsp;<code>&#39;X&#39;</code>。如果两个元素在水平或垂直方向相邻，则称它们是&ldquo;相连&rdquo;的。</p>\n",
        "topicTags": [
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            },
            {
                "name": "Breadth-first Search",
                "slug": "breadth-first-search"
            },
            {
                "name": "Union Find",
                "slug": "union-find"
            }
        ]
    },
    {
        "questionId": "131",
        "questionFrontendId": "131",
        "questionTitle": "Palindrome Partitioning",
        "translatedTitle": "分割回文串",
        "questionTitleSlug": "palindrome-partitioning",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"49.1K\", \"totalSubmission\": \"70.9K\", \"totalAcceptedRaw\": 49110, \"totalSubmissionRaw\": 70853, \"acRate\": \"69.3%\"}",
        "translatedContent": "<p>给定一个字符串 <em>s</em>，将<em> s </em>分割成一些子串，使每个子串都是回文串。</p>\n\n<p>返回 <em>s</em> 所有可能的分割方案。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong>&nbsp;&quot;aab&quot;\n<strong>输出:</strong>\n[\n  [&quot;aa&quot;,&quot;b&quot;],\n  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]\n]</pre>\n",
        "topicTags": [
            {
                "name": "Backtracking",
                "slug": "backtracking"
            }
        ]
    },
    {
        "questionId": "132",
        "questionFrontendId": "132",
        "questionTitle": "Palindrome Partitioning II",
        "translatedTitle": "分割回文串 II",
        "questionTitleSlug": "palindrome-partitioning-ii",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"16.8K\", \"totalSubmission\": \"37.9K\", \"totalAcceptedRaw\": 16784, \"totalSubmissionRaw\": 37894, \"acRate\": \"44.3%\"}",
        "translatedContent": "<p>给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串。</p>\n\n<p>返回符合要求的最少分割次数。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong>&nbsp;&quot;aab&quot;\n<strong>输出:</strong> 1\n<strong>解释: </strong>进行一次分割就可将&nbsp;<em>s </em>分割成 [&quot;aa&quot;,&quot;b&quot;] 这样两个回文子串。\n</pre>\n",
        "topicTags": [
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "133",
        "questionFrontendId": "133",
        "questionTitle": "Clone Graph",
        "translatedTitle": "克隆图",
        "questionTitleSlug": "clone-graph",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"49.1K\", \"totalSubmission\": \"75.5K\", \"totalAcceptedRaw\": 49128, \"totalSubmissionRaw\": 75490, \"acRate\": \"65.1%\"}",
        "translatedContent": "<p>给你无向&nbsp;<strong><a href=\"https://baike.baidu.com/item/连通图/6460995?fr=aladdin\" target=\"_blank\">连通</a>&nbsp;</strong>图中一个节点的引用，请你返回该图的&nbsp;<a href=\"https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin\" target=\"_blank\"><strong>深拷贝</strong></a>（克隆）。</p>\n\n<p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p>\n\n<pre>class Node {\n    public int val;\n    public List&lt;Node&gt; neighbors;\n}</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>测试用例格式：</strong></p>\n\n<p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（<code>val = 1</code>），第二个节点值为 2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p>\n\n<p><strong>邻接列表</strong> 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p>\n\n<p>给定节点将始终是图中的第一个节点（值为 1）。你必须将&nbsp;<strong>给定节点的拷贝&nbsp;</strong>作为对克隆图的引用返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png\" style=\"height: 500px; width: 500px;\"></p>\n\n<pre><strong>输入：</strong>adjList = [[2,4],[1,3],[2,4],[1,3]]\n<strong>输出：</strong>[[2,4],[1,3],[2,4],[1,3]]\n<strong>解释：\n</strong>图中有 4 个节点。\n节点 1 的值是 1，它有两个邻居：节点 2 和 4 。\n节点 2 的值是 2，它有两个邻居：节点 1 和 3 。\n节点 3 的值是 3，它有两个邻居：节点 2 和 4 。\n节点 4 的值是 4，它有两个邻居：节点 1 和 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph.png\" style=\"height: 148px; width: 163px;\"></p>\n\n<pre><strong>输入：</strong>adjList = [[]]\n<strong>输出：</strong>[[]]\n<strong>解释：</strong>输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>adjList = []\n<strong>输出：</strong>[]\n<strong>解释：</strong>这个图是空的，它不含任何节点。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph-1.png\" style=\"height: 133px; width: 272px;\"></p>\n\n<pre><strong>输入：</strong>adjList = [[2],[1]]\n<strong>输出：</strong>[[2],[1]]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>节点数不超过 100 。</li>\n\t<li>每个节点值&nbsp;<code>Node.val</code> 都是唯一的，<code>1 &lt;= Node.val &lt;= 100</code>。</li>\n\t<li>无向图是一个<a href=\"https://baike.baidu.com/item/简单图/1680528?fr=aladdin\" target=\"_blank\">简单图</a>，这意味着图中没有重复的边，也没有自环。</li>\n\t<li>由于图是无向的，如果节点 <em>p</em> 是节点 <em>q</em> 的邻居，那么节点 <em>q</em> 也必须是节点 <em>p</em>&nbsp;的邻居。</li>\n\t<li>图是连通图，你可以从给定节点访问到所有节点。</li>\n</ol>\n",
        "topicTags": [
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            },
            {
                "name": "Breadth-first Search",
                "slug": "breadth-first-search"
            },
            {
                "name": "Graph",
                "slug": "graph"
            }
        ]
    },
    {
        "questionId": "134",
        "questionFrontendId": "134",
        "questionTitle": "Gas Station",
        "translatedTitle": "加油站",
        "questionTitleSlug": "gas-station",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"49.9K\", \"totalSubmission\": \"91.8K\", \"totalAcceptedRaw\": 49904, \"totalSubmissionRaw\": 91792, \"acRate\": \"54.4%\"}",
        "translatedContent": "<p>在一条环路上有&nbsp;<em>N</em>&nbsp;个加油站，其中第&nbsp;<em>i</em>&nbsp;个加油站有汽油&nbsp;<code>gas[i]</code><em>&nbsp;</em>升。</p>\n\n<p>你有一辆油箱容量无限的的汽车，从第<em> i </em>个加油站开往第<em> i+1&nbsp;</em>个加油站需要消耗汽油&nbsp;<code>cost[i]</code><em>&nbsp;</em>升。你从其中的一个加油站出发，开始时油箱为空。</p>\n\n<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>\n\n<p><strong>说明:</strong>&nbsp;</p>\n\n<ul>\n\t<li>如果题目有解，该答案即为唯一答案。</li>\n\t<li>输入数组均为非空数组，且长度相同。</li>\n\t<li>输入数组中的元素均为非负数。</li>\n</ul>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> \ngas  = [1,2,3,4,5]\ncost = [3,4,5,1,2]\n\n<strong>输出:</strong> 3\n\n<strong>解释:\n</strong>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油\n开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油\n开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油\n开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油\n开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油\n开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。\n因此，3 可为起始索引。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> \ngas  = [2,3,4]\ncost = [3,4,3]\n\n<strong>输出:</strong> -1\n\n<strong>解释:\n</strong>你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。\n我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油\n开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油\n开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油\n你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。\n因此，无论怎样，你都不可能绕环路行驶一周。</pre>\n",
        "topicTags": [
            {
                "name": "Greedy",
                "slug": "greedy"
            }
        ]
    },
    {
        "questionId": "135",
        "questionFrontendId": "135",
        "questionTitle": "Candy",
        "translatedTitle": "分发糖果",
        "questionTitleSlug": "candy",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"31K\", \"totalSubmission\": \"69.1K\", \"totalAcceptedRaw\": 30974, \"totalSubmissionRaw\": 69145, \"acRate\": \"44.8%\"}",
        "translatedContent": "<p>老师想给孩子们分发糖果，有 <em>N</em>&nbsp;个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>\n\n<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>\n\n<ul>\n\t<li>每个孩子至少分配到 1 个糖果。</li>\n\t<li>相邻的孩子中，评分高的孩子必须获得更多的糖果。</li>\n</ul>\n\n<p>那么这样下来，老师至少需要准备多少颗糖果呢？</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> [1,0,2]\n<strong>输出:</strong> 5\n<strong>解释:</strong> 你可以分别给这三个孩子分发 2、1、2 颗糖果。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> [1,2,2]\n<strong>输出:</strong> 4\n<strong>解释:</strong> 你可以分别给这三个孩子分发 1、2、1 颗糖果。\n     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</pre>\n",
        "topicTags": [
            {
                "name": "Greedy",
                "slug": "greedy"
            }
        ]
    },
    {
        "questionId": "136",
        "questionFrontendId": "136",
        "questionTitle": "Single Number",
        "translatedTitle": "只出现一次的数字",
        "questionTitleSlug": "single-number",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"283.8K\", \"totalSubmission\": \"404.7K\", \"totalAcceptedRaw\": 283787, \"totalSubmissionRaw\": 404709, \"acRate\": \"70.1%\"}",
        "translatedContent": "<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>\n\n<p><strong>说明：</strong></p>\n\n<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> [2,2,1]\n<strong>输出:</strong> 1\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> [4,1,2,1,2]\n<strong>输出:</strong> 4</pre>\n",
        "topicTags": [
            {
                "name": "Bit Manipulation",
                "slug": "bit-manipulation"
            },
            {
                "name": "Hash Table",
                "slug": "hash-table"
            }
        ]
    },
    {
        "questionId": "137",
        "questionFrontendId": "137",
        "questionTitle": "Single Number II",
        "translatedTitle": "只出现一次的数字 II",
        "questionTitleSlug": "single-number-ii",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"43.6K\", \"totalSubmission\": \"63.9K\", \"totalAcceptedRaw\": 43554, \"totalSubmissionRaw\": 63949, \"acRate\": \"68.1%\"}",
        "translatedContent": "<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p>\n\n<p><strong>说明：</strong></p>\n\n<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> [2,2,3,2]\n<strong>输出:</strong> 3\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> [0,1,0,1,0,1,99]\n<strong>输出:</strong> 99</pre>\n",
        "topicTags": [
            {
                "name": "Bit Manipulation",
                "slug": "bit-manipulation"
            }
        ]
    },
    {
        "questionId": "138",
        "questionFrontendId": "138",
        "questionTitle": "Copy List with Random Pointer",
        "translatedTitle": "复制带随机指针的链表",
        "questionTitleSlug": "copy-list-with-random-pointer",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"48.9K\", \"totalSubmission\": \"85K\", \"totalAcceptedRaw\": 48927, \"totalSubmissionRaw\": 85012, \"acRate\": \"57.6%\"}",
        "translatedContent": "<p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p>\n\n<p>要求返回这个链表的&nbsp;<strong><a href=\"https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin\" target=\"_blank\">深拷贝</a></strong>。&nbsp;</p>\n\n<p>我们用一个由&nbsp;<code>n</code>&nbsp;个节点组成的链表来表示输入/输出中的链表。每个节点用一个&nbsp;<code>[val, random_index]</code>&nbsp;表示：</p>\n\n<ul>\n\t<li><code>val</code>：一个表示&nbsp;<code>Node.val</code>&nbsp;的整数。</li>\n\t<li><code>random_index</code>：随机指针指向的节点索引（范围从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n-1</code>）；如果不指向任何节点，则为&nbsp;&nbsp;<code>null</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png\" style=\"height: 138px; width: 680px;\"></p>\n\n<pre><strong>输入：</strong>head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n<strong>输出：</strong>[[7,null],[13,0],[11,4],[10,2],[1,0]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png\" style=\"height: 111px; width: 680px;\"></p>\n\n<pre><strong>输入：</strong>head = [[1,1],[2,1]]\n<strong>输出：</strong>[[1,1],[2,1]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png\" style=\"height: 119px; width: 680px;\"></strong></p>\n\n<pre><strong>输入：</strong>head = [[3,null],[3,0],[3,null]]\n<strong>输出：</strong>[[3,null],[3,0],[3,null]]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>head = []\n<strong>输出：</strong>[]\n<strong>解释：</strong>给定的链表为空（空指针），因此返回 null。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-10000 &lt;= Node.val &lt;= 10000</code></li>\n\t<li><code>Node.random</code>&nbsp;为空（null）或指向链表中的节点。</li>\n\t<li>节点数目不超过 1000 。</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Hash Table",
                "slug": "hash-table"
            },
            {
                "name": "Linked List",
                "slug": "linked-list"
            }
        ]
    },
    {
        "questionId": "139",
        "questionFrontendId": "139",
        "questionTitle": "Word Break",
        "translatedTitle": "单词拆分",
        "questionTitleSlug": "word-break",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"95.8K\", \"totalSubmission\": \"199.9K\", \"totalAcceptedRaw\": 95812, \"totalSubmissionRaw\": 199948, \"acRate\": \"47.9%\"}",
        "translatedContent": "<p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词的列表 <em>wordDict</em>，判定&nbsp;<em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>拆分时可以重复使用字典中的单词。</li>\n\t<li>你可以假设字典中没有重复的单词。</li>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入:</strong> s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]\n<strong>输出:</strong> true\n<strong>解释:</strong> 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入:</strong> s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]\n<strong>输出:</strong> true\n<strong>解释:</strong> 返回 true 因为 <code>&quot;</code>applepenapple<code>&quot;</code> 可以被拆分成 <code>&quot;</code>apple pen apple<code>&quot;</code>。\n&nbsp;    注意你可以重复使用字典中的单词。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]\n<strong>输出:</strong> false\n</pre>\n",
        "topicTags": [
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "140",
        "questionFrontendId": "140",
        "questionTitle": "Word Break II",
        "translatedTitle": "单词拆分 II",
        "questionTitleSlug": "word-break-ii",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"22.4K\", \"totalSubmission\": \"57.9K\", \"totalAcceptedRaw\": 22371, \"totalSubmissionRaw\": 57872, \"acRate\": \"38.7%\"}",
        "translatedContent": "<p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词列表的字典 <em>wordDict</em>，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>分隔时可以重复使用字典中的单词。</li>\n\t<li>你可以假设字典中没有重复的单词。</li>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入:\n</strong>s = &quot;<code>catsanddog</code>&quot;\nwordDict = <code>[&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</code>\n<strong>输出:\n</strong><code>[\n&nbsp; &quot;cats and dog&quot;,\n&nbsp; &quot;cat sand dog&quot;\n]</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入:\n</strong>s = &quot;pineapplepenapple&quot;\nwordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;]\n<strong>输出:\n</strong>[\n&nbsp; &quot;pine apple pen apple&quot;,\n&nbsp; &quot;pineapple pen apple&quot;,\n&nbsp; &quot;pine applepen apple&quot;\n]\n<strong>解释:</strong> 注意你可以重复使用字典中的单词。\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre><strong>输入:\n</strong>s = &quot;catsandog&quot;\nwordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]\n<strong>输出:\n</strong>[]\n</pre>\n",
        "topicTags": [
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            },
            {
                "name": "Backtracking",
                "slug": "backtracking"
            }
        ]
    },
    {
        "questionId": "141",
        "questionFrontendId": "141",
        "questionTitle": "Linked List Cycle",
        "translatedTitle": "环形链表",
        "questionTitleSlug": "linked-list-cycle",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"273.8K\", \"totalSubmission\": \"544.9K\", \"totalAcceptedRaw\": 273841, \"totalSubmissionRaw\": 544858, \"acRate\": \"50.3%\"}",
        "translatedContent": "<p>给定一个链表，判断链表中是否有环。</p>\n\n<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>\n\n<p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你能用 <em>O(1)</em>（即，常量）内存解决此问题吗？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png\" style=\"height: 97px; width: 300px;\"></p>\n\n<pre><strong>输入：</strong>head = [3,2,0,-4], pos = 1\n<strong>输出：</strong>true\n<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"height: 74px; width: 141px;\"></p>\n\n<pre><strong>输入：</strong>head = [1,2], pos = 0\n<strong>输出：</strong>true\n<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"height: 45px; width: 45px;\"></p>\n\n<pre><strong>输入：</strong>head = [1], pos = -1\n<strong>输出：</strong>false\n<strong>解释：</strong>链表中没有环。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目范围是 <code>[0, 10<sup>4</sup>]</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Linked List",
                "slug": "linked-list"
            },
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            }
        ]
    },
    {
        "questionId": "142",
        "questionFrontendId": "142",
        "questionTitle": "Linked List Cycle II",
        "translatedTitle": "环形链表 II",
        "questionTitleSlug": "linked-list-cycle-ii",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"148.9K\", \"totalSubmission\": \"276.3K\", \"totalAcceptedRaw\": 148932, \"totalSubmissionRaw\": 276341, \"acRate\": \"53.9%\"}",
        "translatedContent": "<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>\n\n<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意，<code>pos</code> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</strong></p>\n\n<p><strong>说明：</strong>不允许修改给定的链表。</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你是否可以使用 <code>O(1)</code> 空间解决此题？</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png\" style=\"height: 97px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [3,2,0,-4], pos = 1\n<strong>输出：</strong>返回索引为 1 的链表节点\n<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"height: 74px; width: 141px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2], pos = 0\n<strong>输出：</strong>返回索引为 0 的链表节点\n<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"height: 45px; width: 45px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1], pos = -1\n<strong>输出：</strong>返回 null\n<strong>解释：</strong>链表中没有环。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目范围在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-10<sup>5</sup> <= Node.val <= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Linked List",
                "slug": "linked-list"
            },
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            }
        ]
    },
    {
        "questionId": "143",
        "questionFrontendId": "143",
        "questionTitle": "Reorder List",
        "translatedTitle": "重排链表",
        "questionTitleSlug": "reorder-list",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"50.7K\", \"totalSubmission\": \"86.8K\", \"totalAcceptedRaw\": 50671, \"totalSubmissionRaw\": 86757, \"acRate\": \"58.4%\"}",
        "translatedContent": "<p>给定一个单链表&nbsp;<em>L</em>：<em>L</em><sub>0</sub>&rarr;<em>L</em><sub>1</sub>&rarr;&hellip;&rarr;<em>L</em><sub><em>n</em>-1</sub>&rarr;<em>L</em><sub>n ，</sub><br>\n将其重新排列后变为： <em>L</em><sub>0</sub>&rarr;<em>L</em><sub><em>n</em></sub>&rarr;<em>L</em><sub>1</sub>&rarr;<em>L</em><sub><em>n</em>-1</sub>&rarr;<em>L</em><sub>2</sub>&rarr;<em>L</em><sub><em>n</em>-2</sub>&rarr;&hellip;</p>\n\n<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</pre>\n",
        "topicTags": [
            {
                "name": "Linked List",
                "slug": "linked-list"
            }
        ]
    },
    {
        "questionId": "144",
        "questionFrontendId": "144",
        "questionTitle": "Binary Tree Preorder Traversal",
        "translatedTitle": "二叉树的前序遍历",
        "questionTitleSlug": "binary-tree-preorder-traversal",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"184.1K\", \"totalSubmission\": \"274.1K\", \"totalAcceptedRaw\": 184087, \"totalSubmissionRaw\": 274089, \"acRate\": \"67.2%\"}",
        "translatedContent": "<p>给定一个二叉树，返回它的&nbsp;<em>前序&nbsp;</em>遍历。</p>\n\n<p>&nbsp;<strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> [1,null,2,3]  \n   1\n    \\\n     2\n    /\n   3 \n\n<strong>输出:</strong> [1,2,3]\n</pre>\n\n<p><strong>进阶:</strong>&nbsp;递归算法很简单，你可以通过迭代算法完成吗？</p>\n",
        "topicTags": [
            {
                "name": "Stack",
                "slug": "stack"
            },
            {
                "name": "Tree",
                "slug": "tree"
            }
        ]
    },
    {
        "questionId": "145",
        "questionFrontendId": "145",
        "questionTitle": "Binary Tree Postorder Traversal",
        "translatedTitle": "二叉树的后序遍历",
        "questionTitleSlug": "binary-tree-postorder-traversal",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"154.2K\", \"totalSubmission\": \"210.2K\", \"totalAcceptedRaw\": 154230, \"totalSubmissionRaw\": 210243, \"acRate\": \"73.4%\"}",
        "translatedContent": "<p>给定一个二叉树，返回它的 <em>后序&nbsp;</em>遍历。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> [1,null,2,3]  \n   1\n    \\\n     2\n    /\n   3 \n\n<strong>输出:</strong> [3,2,1]</pre>\n\n<p><strong>进阶:</strong>&nbsp;递归算法很简单，你可以通过迭代算法完成吗？</p>\n",
        "topicTags": [
            {
                "name": "Stack",
                "slug": "stack"
            },
            {
                "name": "Tree",
                "slug": "tree"
            }
        ]
    },
    {
        "questionId": "146",
        "questionFrontendId": "146",
        "questionTitle": "LRU Cache",
        "translatedTitle": "LRU缓存机制",
        "questionTitleSlug": "lru-cache",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"106.9K\", \"totalSubmission\": \"209.5K\", \"totalAcceptedRaw\": 106905, \"totalSubmissionRaw\": 209479, \"acRate\": \"51.0%\"}",
        "translatedContent": "<p>运用你所掌握的数据结构，设计和实现一个&nbsp; <a href=\"https://baike.baidu.com/item/LRU\" target=\"_blank\">LRU (最近最少使用) 缓存机制</a>。它应该支持以下操作： 获取数据 <code>get</code> 和 写入数据 <code>put</code> 。</p>\n\n<p>获取数据 <code>get(key)</code> - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。<br>\n写入数据 <code>put(key, value)</code> - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶:</strong></p>\n\n<p>你是否可以在&nbsp;<strong>O(1)</strong> 时间复杂度内完成这两种操作？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // 返回  1\ncache.put(3, 3);    // 该操作会使得关键字 2 作废\ncache.get(2);       // 返回 -1 (未找到)\ncache.put(4, 4);    // 该操作会使得关键字 1 作废\ncache.get(1);       // 返回 -1 (未找到)\ncache.get(3);       // 返回  3\ncache.get(4);       // 返回  4\n</pre>\n",
        "topicTags": [
            {
                "name": "Design",
                "slug": "design"
            }
        ]
    },
    {
        "questionId": "147",
        "questionFrontendId": "147",
        "questionTitle": "Insertion Sort List",
        "translatedTitle": "对链表进行插入排序",
        "questionTitleSlug": "insertion-sort-list",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"42.8K\", \"totalSubmission\": \"65.5K\", \"totalAcceptedRaw\": 42827, \"totalSubmissionRaw\": 65503, \"acRate\": \"65.4%\"}",
        "translatedContent": "<p>对链表进行插入排序。</p>\n\n<p><img alt=\"\" src=\"https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif\"><br>\n<small>插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。<br>\n每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。</small></p>\n\n<p>&nbsp;</p>\n\n<p><strong>插入排序算法：</strong></p>\n\n<ol>\n\t<li>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。</li>\n\t<li>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。</li>\n\t<li>重复直到所有输入数据插入完为止。</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入:</strong> 4-&gt;2-&gt;1-&gt;3\n<strong>输出:</strong> 1-&gt;2-&gt;3-&gt;4\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre><strong>输入:</strong> -1-&gt;5-&gt;3-&gt;4-&gt;0\n<strong>输出:</strong> -1-&gt;0-&gt;3-&gt;4-&gt;5\n</pre>\n",
        "topicTags": [
            {
                "name": "Sort",
                "slug": "sort"
            },
            {
                "name": "Linked List",
                "slug": "linked-list"
            }
        ]
    },
    {
        "questionId": "148",
        "questionFrontendId": "148",
        "questionTitle": "Sort List",
        "translatedTitle": "排序链表",
        "questionTitleSlug": "sort-list",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"97.7K\", \"totalSubmission\": \"145.4K\", \"totalAcceptedRaw\": 97660, \"totalSubmissionRaw\": 145381, \"acRate\": \"67.2%\"}",
        "translatedContent": "<p>在&nbsp;<em>O</em>(<em>n</em>&nbsp;log&nbsp;<em>n</em>) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> 4-&gt;2-&gt;1-&gt;3\n<strong>输出:</strong> 1-&gt;2-&gt;3-&gt;4\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> -1-&gt;5-&gt;3-&gt;4-&gt;0\n<strong>输出:</strong> -1-&gt;0-&gt;3-&gt;4-&gt;5</pre>\n",
        "topicTags": [
            {
                "name": "Sort",
                "slug": "sort"
            },
            {
                "name": "Linked List",
                "slug": "linked-list"
            }
        ]
    },
    {
        "questionId": "149",
        "questionFrontendId": "149",
        "questionTitle": "Max Points on a Line",
        "translatedTitle": "直线上最多的点数",
        "questionTitleSlug": "max-points-on-a-line",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"16.9K\", \"totalSubmission\": \"72.8K\", \"totalAcceptedRaw\": 16901, \"totalSubmissionRaw\": 72807, \"acRate\": \"23.2%\"}",
        "translatedContent": "<p>给定一个二维平面，平面上有&nbsp;<em>n&nbsp;</em>个点，求最多有多少个点在同一条直线上。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> [[1,1],[2,2],[3,3]]\n<strong>输出:</strong> 3\n<strong>解释:</strong>\n^\n|\n| &nbsp; &nbsp; &nbsp; &nbsp;o\n| &nbsp; &nbsp; o\n| &nbsp;o &nbsp;\n+-------------&gt;\n0 &nbsp;1 &nbsp;2 &nbsp;3  4\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\n<strong>输出:</strong> 4\n<strong>解释:</strong>\n^\n|\n|  o\n| &nbsp;&nbsp;&nbsp;&nbsp;o&nbsp;&nbsp;      o\n| &nbsp;&nbsp;&nbsp;&nbsp;   o\n| &nbsp;o &nbsp;      o\n+-------------------&gt;\n0 &nbsp;1 &nbsp;2 &nbsp;3 &nbsp;4 &nbsp;5 &nbsp;6</pre>\n",
        "topicTags": [
            {
                "name": "Hash Table",
                "slug": "hash-table"
            },
            {
                "name": "Math",
                "slug": "math"
            }
        ]
    },
    {
        "questionId": "150",
        "questionFrontendId": "150",
        "questionTitle": "Evaluate Reverse Polish Notation",
        "translatedTitle": "逆波兰表达式求值",
        "questionTitleSlug": "evaluate-reverse-polish-notation",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"57.7K\", \"totalSubmission\": \"114.1K\", \"totalAcceptedRaw\": 57665, \"totalSubmissionRaw\": 114112, \"acRate\": \"50.5%\"}",
        "translatedContent": "<p>根据<a href=\"https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437\" target=\"_blank\"> 逆波兰表示法</a>，求表达式的值。</p>\n\n<p>有效的运算符包括&nbsp;<code>+</code>,&nbsp;<code>-</code>,&nbsp;<code>*</code>,&nbsp;<code>/</code>&nbsp;。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>整数除法只保留整数部分。</li>\n\t<li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre><strong>输入:</strong> [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]\n<strong>输出:</strong> 9\n<strong>解释:</strong> 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre><strong>输入:</strong> [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]\n<strong>输出:</strong> 6\n<strong>解释:</strong> 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre><strong>输入:</strong> [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]\n<strong>输出:</strong> 22\n<strong>解释:</strong> \n该算式转化为常见的中缀算术表达式为：\n  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>逆波兰表达式：</strong></p>\n\n<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>\n\n<ul>\n\t<li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li>\n\t<li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li>\n</ul>\n\n<p>逆波兰表达式主要有以下两个优点：</p>\n\n<ul>\n\t<li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li>\n\t<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Stack",
                "slug": "stack"
            }
        ]
    },
    {
        "questionId": "151",
        "questionFrontendId": "151",
        "questionTitle": "Reverse Words in a String",
        "translatedTitle": "翻转字符串里的单词",
        "questionTitleSlug": "reverse-words-in-a-string",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"100.4K\", \"totalSubmission\": \"229.5K\", \"totalAcceptedRaw\": 100381, \"totalSubmissionRaw\": 229494, \"acRate\": \"43.7%\"}",
        "translatedContent": "<p>给定一个字符串，逐个翻转字符串中的每个单词。</p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>无空格字符构成一个 <strong>单词</strong> 。</li>\n\t<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>\n\t<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>&quot;<code>the sky is blue</code>&quot;\n<strong>输出：</strong>&quot;<code>blue is sky the</code>&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>&quot; &nbsp;hello world! &nbsp;&quot;\n<strong>输出：</strong>&quot;world! hello&quot;\n<strong>解释：</strong>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>&quot;a good &nbsp; example&quot;\n<strong>输出：</strong>&quot;example good a&quot;\n<strong>解释：</strong>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;  Bob    Loves  Alice   &quot;\n<strong>输出：</strong>&quot;Alice Loves Bob&quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;Alice does not even like bob&quot;\n<strong>输出：</strong>&quot;bob like even not does Alice&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> 包含英文大小写字母、数字和空格 <code>&#39; &#39;</code></li>\n\t<li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li>\n</ul>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>请尝试使用&nbsp;<em>O</em>(1) 额外空间复杂度的原地解法。</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "152",
        "questionFrontendId": "152",
        "questionTitle": "Maximum Product Subarray",
        "translatedTitle": "乘积最大子数组",
        "questionTitleSlug": "maximum-product-subarray",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"99.4K\", \"totalSubmission\": \"245.6K\", \"totalAcceptedRaw\": 99376, \"totalSubmissionRaw\": 245554, \"acRate\": \"40.5%\"}",
        "translatedContent": "<p>给你一个整数数组 <code>nums</code>&nbsp;，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> [2,3,-2,4]\n<strong>输出:</strong> <code>6</code>\n<strong>解释:</strong>&nbsp;子数组 [2,3] 有最大乘积 6。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> [-2,0,-1]\n<strong>输出:</strong> 0\n<strong>解释:</strong>&nbsp;结果不能为 2, 因为 [-2,-1] 不是子数组。</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "153",
        "questionFrontendId": "153",
        "questionTitle": "Find Minimum in Rotated Sorted Array",
        "translatedTitle": "寻找旋转排序数组中的最小值",
        "questionTitleSlug": "find-minimum-in-rotated-sorted-array",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"83.8K\", \"totalSubmission\": \"161.9K\", \"totalAcceptedRaw\": 83814, \"totalSubmissionRaw\": 161886, \"acRate\": \"51.8%\"}",
        "translatedContent": "<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>\n\n<p>( 例如，数组&nbsp;<code>[0,1,2,4,5,6,7]</code> <strong> </strong>可能变为&nbsp;<code>[4,5,6,7,0,1,2]</code>&nbsp;)。</p>\n\n<p>请找出其中最小的元素。</p>\n\n<p>你可以假设数组中不存在重复元素。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> [3,4,5,1,2]\n<strong>输出:</strong> 1</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> [4,5,6,7,0,1,2]\n<strong>输出:</strong> 0</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Binary Search",
                "slug": "binary-search"
            }
        ]
    },
    {
        "questionId": "154",
        "questionFrontendId": "154",
        "questionTitle": "Find Minimum in Rotated Sorted Array II",
        "translatedTitle": "寻找旋转排序数组中的最小值 II",
        "questionTitleSlug": "find-minimum-in-rotated-sorted-array-ii",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"39.4K\", \"totalSubmission\": \"78.1K\", \"totalAcceptedRaw\": 39369, \"totalSubmissionRaw\": 78101, \"acRate\": \"50.4%\"}",
        "translatedContent": "<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>\n\n<p>( 例如，数组&nbsp;<code>[0,1,2,4,5,6,7]</code> <strong> </strong>可能变为&nbsp;<code>[4,5,6,7,0,1,2]</code>&nbsp;)。</p>\n\n<p>请找出其中最小的元素。</p>\n\n<p>注意数组中可能存在重复的元素。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入:</strong> [1,3,5]\n<strong>输出:</strong> 1</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre><strong>输入:</strong> [2,2,2,0,1]\n<strong>输出:</strong> 0</pre>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>这道题是&nbsp;<a href=\"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/\">寻找旋转排序数组中的最小值</a>&nbsp;的延伸题目。</li>\n\t<li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Binary Search",
                "slug": "binary-search"
            }
        ]
    },
    {
        "questionId": "155",
        "questionFrontendId": "155",
        "questionTitle": "Min Stack",
        "translatedTitle": "最小栈",
        "questionTitleSlug": "min-stack",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"170.5K\", \"totalSubmission\": \"307K\", \"totalAcceptedRaw\": 170458, \"totalSubmissionRaw\": 307044, \"acRate\": \"55.5%\"}",
        "translatedContent": "<p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>\n\n<ul>\n\t<li><code>push(x)</code> &mdash;&mdash; 将元素 x 推入栈中。</li>\n\t<li><code>pop()</code>&nbsp;&mdash;&mdash; 删除栈顶的元素。</li>\n\t<li><code>top()</code>&nbsp;&mdash;&mdash; 获取栈顶元素。</li>\n\t<li><code>getMin()</code> &mdash;&mdash; 检索栈中的最小元素。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入：</strong>\n[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n<strong>输出：</strong>\n[null,null,null,null,-3,null,0,-2]\n\n<strong>解释：</strong>\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --&gt; 返回 -3.\nminStack.pop();\nminStack.top();      --&gt; 返回 0.\nminStack.getMin();   --&gt; 返回 -2.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用。</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Stack",
                "slug": "stack"
            },
            {
                "name": "Design",
                "slug": "design"
            }
        ]
    },
    {
        "questionId": "156",
        "questionFrontendId": "156",
        "questionTitle": "Binary Tree Upside Down",
        "translatedTitle": "上下翻转二叉树",
        "questionTitleSlug": "binary-tree-upside-down",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"3.5K\", \"totalSubmission\": \"4.7K\", \"totalAcceptedRaw\": 3514, \"totalSubmissionRaw\": 4692, \"acRate\": \"74.9%\"}",
        "translatedContent": null,
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            }
        ]
    },
    {
        "questionId": "157",
        "questionFrontendId": "157",
        "questionTitle": "Read N Characters Given Read4",
        "translatedTitle": "用 Read4 读取 N 个字符",
        "questionTitleSlug": "read-n-characters-given-read4",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"2.9K\", \"totalSubmission\": \"5.6K\", \"totalAcceptedRaw\": 2899, \"totalSubmissionRaw\": 5638, \"acRate\": \"51.4%\"}",
        "translatedContent": null,
        "topicTags": [
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "158",
        "questionFrontendId": "158",
        "questionTitle": "Read N Characters Given Read4 II - Call multiple times",
        "translatedTitle": "用 Read4 读取 N 个字符 II",
        "questionTitleSlug": "read-n-characters-given-read4-ii-call-multiple-times",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"1.4K\", \"totalSubmission\": \"2.6K\", \"totalAcceptedRaw\": 1424, \"totalSubmissionRaw\": 2611, \"acRate\": \"54.5%\"}",
        "translatedContent": null,
        "topicTags": [
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "159",
        "questionFrontendId": "159",
        "questionTitle": "Longest Substring with At Most Two Distinct Characters",
        "translatedTitle": "至多包含两个不同字符的最长子串",
        "questionTitleSlug": "longest-substring-with-at-most-two-distinct-characters",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"7.3K\", \"totalSubmission\": \"14.1K\", \"totalAcceptedRaw\": 7292, \"totalSubmissionRaw\": 14067, \"acRate\": \"51.8%\"}",
        "translatedContent": null,
        "topicTags": [
            {
                "name": "Hash Table",
                "slug": "hash-table"
            },
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            },
            {
                "name": "String",
                "slug": "string"
            },
            {
                "name": "Sliding Window",
                "slug": "sliding-window"
            }
        ]
    },
    {
        "questionId": "160",
        "questionFrontendId": "160",
        "questionTitle": "Intersection of Two Linked Lists",
        "translatedTitle": "相交链表",
        "questionTitleSlug": "intersection-of-two-linked-lists",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"158.9K\", \"totalSubmission\": \"280K\", \"totalAcceptedRaw\": 158852, \"totalSubmissionRaw\": 279999, \"acRate\": \"56.7%\"}",
        "translatedContent": "<p>编写一个程序，找到两个单链表相交的起始节点。</p>\n\n<p>如下面的两个链表<strong>：</strong></p>\n\n<p><a href=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" style=\"height: 130px; width: 400px;\"></a></p>\n\n<p>在节点 c1 开始相交。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png\" style=\"height: 130px; width: 400px;\"></a></p>\n\n<pre><strong>输入：</strong>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n<strong>输出：</strong>Reference of the node with value = 8\n<strong>输入解释：</strong>相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png\" style=\"height: 136px; width: 350px;\"></a></p>\n\n<pre><strong>输入：</strong>intersectVal&nbsp;= 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n<strong>输出：</strong>Reference of the node with value = 2\n<strong>输入解释：</strong>相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png\" style=\"height: 126px; width: 200px;\"></a></p>\n\n<pre><strong>输入：</strong>intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n<strong>输出：</strong>null\n<strong>输入解释：</strong>从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n<strong>解释：</strong>这两个链表不相交，因此返回 null。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>如果两个链表没有交点，返回 <code>null</code>.</li>\n\t<li>在返回结果后，两个链表仍须保持原有的结构。</li>\n\t<li>可假定整个链表结构中没有循环。</li>\n\t<li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Linked List",
                "slug": "linked-list"
            }
        ]
    },
    {
        "questionId": "161",
        "questionFrontendId": "161",
        "questionTitle": "One Edit Distance",
        "translatedTitle": "相隔为 1 的编辑距离",
        "questionTitleSlug": "one-edit-distance",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"4.4K\", \"totalSubmission\": \"13.4K\", \"totalAcceptedRaw\": 4379, \"totalSubmissionRaw\": 13351, \"acRate\": \"32.8%\"}",
        "translatedContent": null,
        "topicTags": [
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "162",
        "questionFrontendId": "162",
        "questionTitle": "Find Peak Element",
        "translatedTitle": "寻找峰值",
        "questionTitleSlug": "find-peak-element",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"62.6K\", \"totalSubmission\": \"131.2K\", \"totalAcceptedRaw\": 62628, \"totalSubmissionRaw\": 131218, \"acRate\": \"47.7%\"}",
        "translatedContent": "<p>峰值元素是指其值大于左右相邻值的元素。</p>\n\n<p>给定一个输入数组&nbsp;<code>nums</code>，其中 <code>nums[i] &ne; nums[i+1]</code>，找到峰值元素并返回其索引。</p>\n\n<p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p>\n\n<p>你可以假设&nbsp;<code>nums[-1] = nums[n] = -&infin;</code>。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> <strong>nums</strong> = <code>[1,2,3,1]</code>\n<strong>输出:</strong> 2\n<strong>解释: </strong>3 是峰值元素，你的函数应该返回其索引 2。</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> <strong>nums</strong> = <code>[</code>1,2,1,3,5,6,4]\n<strong>输出:</strong> 1 或 5 \n<strong>解释:</strong> 你的函数可以返回索引 1，其峰值元素为 2；\n&nbsp;    或者返回索引 5， 其峰值元素为 6。\n</pre>\n\n<p><strong>说明:</strong></p>\n\n<p>你的解法应该是&nbsp;<em>O</em>(<em>logN</em>)<em>&nbsp;</em>时间复杂度的。</p>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Binary Search",
                "slug": "binary-search"
            }
        ]
    },
    {
        "questionId": "163",
        "questionFrontendId": "163",
        "questionTitle": "Missing Ranges",
        "translatedTitle": "缺失的区间",
        "questionTitleSlug": "missing-ranges",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"4.8K\", \"totalSubmission\": \"17.7K\", \"totalAcceptedRaw\": 4787, \"totalSubmissionRaw\": 17656, \"acRate\": \"27.1%\"}",
        "translatedContent": null,
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            }
        ]
    },
    {
        "questionId": "164",
        "questionFrontendId": "164",
        "questionTitle": "Maximum Gap",
        "translatedTitle": "最大间距",
        "questionTitleSlug": "maximum-gap",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"19.7K\", \"totalSubmission\": \"35.8K\", \"totalAcceptedRaw\": 19718, \"totalSubmissionRaw\": 35790, \"acRate\": \"55.1%\"}",
        "translatedContent": "<p>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。</p>\n\n<p>如果数组元素个数小于 2，则返回 0。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> [3,6,9,1]\n<strong>输出:</strong> 3\n<strong>解释:</strong> 排序后的数组是 [1,3,6,9]<strong><em>, </em></strong>其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> [10]\n<strong>输出:</strong> 0\n<strong>解释:</strong> 数组元素个数小于 2，因此返回 0。</pre>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。</li>\n\t<li>请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Sort",
                "slug": "sort"
            }
        ]
    },
    {
        "questionId": "165",
        "questionFrontendId": "165",
        "questionTitle": "Compare Version Numbers",
        "translatedTitle": "比较版本号",
        "questionTitleSlug": "compare-version-numbers",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"26.7K\", \"totalSubmission\": \"61.4K\", \"totalAcceptedRaw\": 26667, \"totalSubmissionRaw\": 61379, \"acRate\": \"43.4%\"}",
        "translatedContent": "<p>比较两个版本号 <em>version1&nbsp;</em>和 <em>version2</em>。<br>\n如果&nbsp;<code><em>version1&nbsp;</em>&gt;&nbsp;<em>version2</em></code>&nbsp;返回&nbsp;<code>1</code>，如果&nbsp;<code><em>version1&nbsp;</em>&lt;&nbsp;<em>version2</em></code> 返回 <code>-1</code>， 除此之外返回 <code>0</code>。</p>\n\n<p>你可以假设版本字符串非空，并且只包含数字和&nbsp;<code>.</code> 字符。</p>\n\n<p>&nbsp;<code>.</code> 字符不代表小数点，而是用于分隔数字序列。</p>\n\n<p>例如，<code>2.5</code> 不是&ldquo;两个半&rdquo;，也不是&ldquo;差一半到三&rdquo;，而是第二版中的第五个小版本。</p>\n\n<p>你可以假设版本号的每一级的默认修订版号为 <code>0</code>。例如，版本号 <code>3.4</code> 的第一级（大版本）和第二级（小版本）修订号分别为 <code>3</code> 和 <code>4</code>。其第三级和第四级修订号均为 <code>0</code>。<br>\n&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> <code><em>version1</em></code> = &quot;0.1&quot;, <code><em>version2</em></code> = &quot;1.1&quot;\n<strong>输出:</strong> -1</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入: </strong><code><em>version1</em></code> = &quot;1.0.1&quot;, <code><em>version2</em></code> = &quot;1&quot;\n<strong>输出:</strong> 1</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre><strong>输入:</strong> <code><em>version1</em></code> = &quot;7.5.2.4&quot;, <code><em>version2</em></code> = &quot;7.5.3&quot;\n<strong>输出:</strong> -1</pre>\n\n<p><strong>示例&nbsp;4：</strong></p>\n\n<pre><code><strong>输入：</strong><em>version1</em></code> = &quot;1.01&quot;, <code><em>version2</em></code> = &quot;1.001&quot;\n<strong>输出：</strong>0\n<strong>解释：</strong>忽略前导零，&ldquo;01&rdquo; 和 &ldquo;001&rdquo; 表示相同的数字 &ldquo;1&rdquo;。</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><code><strong>输入：</strong><em>version1</em></code> = &quot;1.0&quot;, <code><em>version2</em></code> = &quot;1.0.0&quot;\n<strong>输出：</strong>0\n<strong>解释：</strong><code><em>version1 </em></code>没有第三级修订号，这意味着它的第三级修订号默认为 &ldquo;0&rdquo;。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>版本字符串由以点&nbsp;（<code>.</code>）&nbsp;分隔的数字字符串组成。这个数字字符串<strong>可能</strong>有前导零。</li>\n\t<li>版本字符串不以点开始或结束，并且其中不会有两个连续的点。</li>\n</ol>\n",
        "topicTags": [
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "166",
        "questionFrontendId": "166",
        "questionTitle": "Fraction to Recurring Decimal",
        "translatedTitle": "分数到小数",
        "questionTitleSlug": "fraction-to-recurring-decimal",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"16.4K\", \"totalSubmission\": \"59.1K\", \"totalAcceptedRaw\": 16427, \"totalSubmissionRaw\": 59101, \"acRate\": \"27.8%\"}",
        "translatedContent": "<p>给定两个整数，分别表示分数的分子&nbsp;numerator 和分母 denominator，以字符串形式返回小数。</p>\n\n<p>如果小数部分为循环小数，则将循环的部分括在括号内。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> numerator = 1, denominator = 2\n<strong>输出:</strong> &quot;0.5&quot;\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> numerator = 2, denominator = 1\n<strong>输出:</strong> &quot;2&quot;</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre><strong>输入:</strong> numerator = 2, denominator = 3\n<strong>输出: </strong>&quot;0.(6)&quot;\n</pre>\n",
        "topicTags": [
            {
                "name": "Hash Table",
                "slug": "hash-table"
            },
            {
                "name": "Math",
                "slug": "math"
            }
        ]
    },
    {
        "questionId": "167",
        "questionFrontendId": "167",
        "questionTitle": "Two Sum II - Input array is sorted",
        "translatedTitle": "两数之和 II - 输入有序数组",
        "questionTitleSlug": "two-sum-ii-input-array-is-sorted",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"162.6K\", \"totalSubmission\": \"286.7K\", \"totalAcceptedRaw\": 162580, \"totalSubmissionRaw\": 286724, \"acRate\": \"56.7%\"}",
        "translatedContent": "<p>给定一个已按照<strong><em>升序排列</em>&nbsp;</strong>的有序数组，找到两个数使得它们相加之和等于目标数。</p>\n\n<p>函数应该返回这两个下标值<em> </em>index1 和 index2，其中 index1&nbsp;必须小于&nbsp;index2<em>。</em></p>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>返回的下标值（index1 和 index2）不是从零开始的。</li>\n\t<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>\n</ul>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> numbers = [2, 7, 11, 15], target = 9\n<strong>输出:</strong> [1,2]\n<strong>解释:</strong> 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</pre>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Two Pointers",
                "slug": "two-pointers"
            },
            {
                "name": "Binary Search",
                "slug": "binary-search"
            }
        ]
    },
    {
        "questionId": "168",
        "questionFrontendId": "168",
        "questionTitle": "Excel Sheet Column Title",
        "translatedTitle": "Excel表列名称",
        "questionTitleSlug": "excel-sheet-column-title",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"37K\", \"totalSubmission\": \"96K\", \"totalAcceptedRaw\": 36990, \"totalSubmissionRaw\": 96041, \"acRate\": \"38.5%\"}",
        "translatedContent": "<p>给定一个正整数，返回它在 Excel 表中相对应的列名称。</p>\n\n<p>例如，</p>\n\n<pre>    1 -&gt; A\n    2 -&gt; B\n    3 -&gt; C\n    ...\n    26 -&gt; Z\n    27 -&gt; AA\n    28 -&gt; AB \n    ...\n</pre>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> 1\n<strong>输出:</strong> &quot;A&quot;\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> 28\n<strong>输出:</strong> &quot;AB&quot;\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre><strong>输入:</strong> 701\n<strong>输出:</strong> &quot;ZY&quot;\n</pre>\n",
        "topicTags": [
            {
                "name": "Math",
                "slug": "math"
            }
        ]
    },
    {
        "questionId": "169",
        "questionFrontendId": "169",
        "questionTitle": "Majority Element",
        "translatedTitle": "多数元素",
        "questionTitleSlug": "majority-element",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"224.8K\", \"totalSubmission\": \"346.8K\", \"totalAcceptedRaw\": 224780, \"totalSubmissionRaw\": 346843, \"acRate\": \"64.8%\"}",
        "translatedContent": "<p>给定一个大小为 <em>n </em>的数组，找到其中的多数元素。多数元素是指在数组中出现次数<strong>大于</strong>&nbsp;<code>&lfloor; n/2 &rfloor;</code>&nbsp;的元素。</p>\n\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> [3,2,3]\n<strong>输出:</strong> 3</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> [2,2,1,1,1,2,2]\n<strong>输出:</strong> 2\n</pre>\n",
        "topicTags": [
            {
                "name": "Bit Manipulation",
                "slug": "bit-manipulation"
            },
            {
                "name": "Array",
                "slug": "array"
            },
            {
                "name": "Divide and Conquer",
                "slug": "divide-and-conquer"
            }
        ]
    },
    {
        "questionId": "170",
        "questionFrontendId": "170",
        "questionTitle": "Two Sum III - Data structure design",
        "translatedTitle": "两数之和 III - 数据结构设计",
        "questionTitleSlug": "two-sum-iii-data-structure-design",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"4.4K\", \"totalSubmission\": \"10.7K\", \"totalAcceptedRaw\": 4429, \"totalSubmissionRaw\": 10740, \"acRate\": \"41.2%\"}",
        "translatedContent": null,
        "topicTags": [
            {
                "name": "Design",
                "slug": "design"
            },
            {
                "name": "Hash Table",
                "slug": "hash-table"
            }
        ]
    },
    {
        "questionId": "171",
        "questionFrontendId": "171",
        "questionTitle": "Excel Sheet Column Number",
        "translatedTitle": "Excel表列序号",
        "questionTitleSlug": "excel-sheet-column-number",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"53.3K\", \"totalSubmission\": \"78.1K\", \"totalAcceptedRaw\": 53297, \"totalSubmissionRaw\": 78063, \"acRate\": \"68.3%\"}",
        "translatedContent": "<p>给定一个Excel表格中的列名称，返回其相应的列序号。</p>\n\n<p>例如，</p>\n\n<pre>    A -&gt; 1\n    B -&gt; 2\n    C -&gt; 3\n    ...\n    Z -&gt; 26\n    AA -&gt; 27\n    AB -&gt; 28 \n    ...\n</pre>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> &quot;A&quot;\n<strong>输出:</strong> 1\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入: </strong>&quot;AB&quot;\n<strong>输出:</strong> 28\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre><strong>输入: </strong>&quot;ZY&quot;\n<strong>输出:</strong> 701</pre>\n\n<p><strong>致谢：</strong><br>\n特别感谢&nbsp;<a href=\"http://leetcode.com/discuss/user/ts\">@ts</a>&nbsp;添加此问题并创建所有测试用例。</p>\n",
        "topicTags": [
            {
                "name": "Math",
                "slug": "math"
            }
        ]
    },
    {
        "questionId": "172",
        "questionFrontendId": "172",
        "questionTitle": "Factorial Trailing Zeroes",
        "translatedTitle": "阶乘后的零",
        "questionTitleSlug": "factorial-trailing-zeroes",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"51.7K\", \"totalSubmission\": \"128K\", \"totalAcceptedRaw\": 51674, \"totalSubmissionRaw\": 128044, \"acRate\": \"40.4%\"}",
        "translatedContent": "<p>给定一个整数 <em>n</em>，返回 <em>n</em>! 结果尾数中零的数量。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> 3\n<strong>输出:</strong> 0\n<strong>解释:</strong>&nbsp;3! = 6, 尾数中没有零。</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> 5\n<strong>输出:</strong> 1\n<strong>解释:</strong>&nbsp;5! = 120, 尾数中有 1 个零.</pre>\n\n<p><strong>说明: </strong>你算法的时间复杂度应为&nbsp;<em>O</em>(log&nbsp;<em>n</em>)<em>&nbsp;</em>。</p>\n",
        "topicTags": [
            {
                "name": "Math",
                "slug": "math"
            }
        ]
    },
    {
        "questionId": "173",
        "questionFrontendId": "173",
        "questionTitle": "Binary Search Tree Iterator",
        "translatedTitle": "二叉搜索树迭代器",
        "questionTitleSlug": "binary-search-tree-iterator",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"31.3K\", \"totalSubmission\": \"41.8K\", \"totalAcceptedRaw\": 31252, \"totalSubmissionRaw\": 41789, \"acRate\": \"74.8%\"}",
        "translatedContent": "<p>实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。</p>\n\n<p>调用 <code>next()</code> 将返回二叉搜索树中的下一个最小的数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/25/bst-tree.png\" style=\"height: 178px; width: 189px;\"></strong></p>\n\n<pre>BSTIterator iterator = new BSTIterator(root);\niterator.next();    // 返回 3\niterator.next();    // 返回 7\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 9\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 15\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 20\niterator.hasNext(); // 返回 false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>next()</code>&nbsp;和&nbsp;<code>hasNext()</code>&nbsp;操作的时间复杂度是&nbsp;O(1)，并使用&nbsp;O(<em>h</em>) 内存，其中&nbsp;<em>h&nbsp;</em>是树的高度。</li>\n\t<li>你可以假设&nbsp;<code>next()</code>&nbsp;调用总是有效的，也就是说，当调用 <code>next()</code>&nbsp;时，BST 中至少存在一个下一个最小的数。</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Stack",
                "slug": "stack"
            },
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Design",
                "slug": "design"
            }
        ]
    },
    {
        "questionId": "174",
        "questionFrontendId": "174",
        "questionTitle": "Dungeon Game",
        "translatedTitle": "地下城游戏",
        "questionTitleSlug": "dungeon-game",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"27.1K\", \"totalSubmission\": \"56.3K\", \"totalAcceptedRaw\": 27089, \"totalSubmissionRaw\": 56339, \"acRate\": \"48.1%\"}",
        "translatedContent": "<style>\r\ntable.dungeon, .dungeon th, .dungeon td {\r\n  border:3px solid black;\r\n}\r\n\r\n .dungeon th, .dungeon td {\r\n    text-align: center;\r\n    height: 70px;\r\n    width: 70px;\r\n}\r\n</style>\r\n\r\n<p>一些恶魔抓住了公主（<strong>P</strong>）并将她关在了地下城的右下角。地下城是由&nbsp;M x N 个房间组成的二维网格。我们英勇的骑士（<strong>K</strong>）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>\r\n\r\n<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>\r\n\r\n<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为<em>负整数</em>，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 <em>0</em>），要么包含增加骑士健康点数的魔法球（若房间里的值为<em>正整数</em>，则表示骑士将增加健康点数）。</p>\r\n\r\n<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</strong></p>\r\n\r\n<p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 <code>右 -&gt; 右 -&gt; 下 -&gt; 下</code>，则骑士的初始健康点数至少为 <strong>7</strong>。</p>\r\n\r\n<table class=\"dungeon\">\r\n<tr> \r\n<td>-2 (K)</td> \r\n<td>-3</td> \r\n<td>3</td> \r\n</tr> \r\n<tr> \r\n<td>-5</td> \r\n<td>-10</td> \r\n<td>1</td> \r\n</tr> \r\n<tr> \r\n<td>10</td> \r\n<td>30</td> \r\n<td>-5 (P)</td> \r\n</tr> \r\n</table>\r\n<!---2K   -3  3\r\n-5   -10   1\r\n10 30   5P-->\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>说明:</strong></p>\r\n\r\n<ul>\r\n\t<li>\r\n\t<p>骑士的健康点数没有上限。</p>\r\n\t</li>\r\n\t<li>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</li>\r\n</ul>",
        "topicTags": [
            {
                "name": "Binary Search",
                "slug": "binary-search"
            },
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "175",
        "questionFrontendId": "175",
        "questionTitle": "Combine Two Tables",
        "translatedTitle": "组合两个表",
        "questionTitleSlug": "combine-two-tables",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"182.8K\", \"totalSubmission\": \"248.2K\", \"totalAcceptedRaw\": 182785, \"totalSubmissionRaw\": 248248, \"acRate\": \"73.6%\"}",
        "translatedContent": "<p>表1: <code>Person</code></p>\n\n<pre>+-------------+---------+\n| 列名         | 类型     |\n+-------------+---------+\n| PersonId    | int     |\n| FirstName   | varchar |\n| LastName    | varchar |\n+-------------+---------+\nPersonId 是上表主键\n</pre>\n\n<p>表2: <code>Address</code></p>\n\n<pre>+-------------+---------+\n| 列名         | 类型    |\n+-------------+---------+\n| AddressId   | int     |\n| PersonId    | int     |\n| City        | varchar |\n| State       | varchar |\n+-------------+---------+\nAddressId 是上表主键\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供&nbsp;person 的以下信息：</p>\n\n<p>&nbsp;</p>\n\n<pre>FirstName, LastName, City, State\n</pre>\n",
        "topicTags": []
    },
    {
        "questionId": "176",
        "questionFrontendId": "176",
        "questionTitle": "Second Highest Salary",
        "translatedTitle": "第二高的薪水",
        "questionTitleSlug": "second-highest-salary",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"146.1K\", \"totalSubmission\": \"411K\", \"totalAcceptedRaw\": 146079, \"totalSubmissionRaw\": 411022, \"acRate\": \"35.5%\"}",
        "translatedContent": "<p>编写一个 SQL 查询，获取 <code>Employee</code>&nbsp;表中第二高的薪水（Salary）&nbsp;。</p>\n\n<pre>+----+--------+\n| Id | Salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\n</pre>\n\n<p>例如上述&nbsp;<code>Employee</code>&nbsp;表，SQL查询应该返回&nbsp;<code>200</code> 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 <code>null</code>。</p>\n\n<pre>+---------------------+\n| SecondHighestSalary |\n+---------------------+\n| 200                 |\n+---------------------+\n</pre>\n",
        "topicTags": []
    },
    {
        "questionId": "177",
        "questionFrontendId": "177",
        "questionTitle": "Nth Highest Salary",
        "translatedTitle": "第N高的薪水",
        "questionTitleSlug": "nth-highest-salary",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"70.7K\", \"totalSubmission\": \"153.6K\", \"totalAcceptedRaw\": 70653, \"totalSubmissionRaw\": 153615, \"acRate\": \"46.0%\"}",
        "translatedContent": "<p>编写一个 SQL 查询，获取 <code>Employee</code> 表中第&nbsp;<em>n&nbsp;</em>高的薪水（Salary）。</p>\n\n<pre>+----+--------+\n| Id | Salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\n</pre>\n\n<p>例如上述&nbsp;<code>Employee</code>&nbsp;表，<em>n = 2&nbsp;</em>时，应返回第二高的薪水&nbsp;<code>200</code>。如果不存在第&nbsp;<em>n&nbsp;</em>高的薪水，那么查询应返回&nbsp;<code>null</code>。</p>\n\n<pre>+------------------------+\n| getNthHighestSalary(2) |\n+------------------------+\n| 200                    |\n+------------------------+\n</pre>\n",
        "topicTags": []
    },
    {
        "questionId": "178",
        "questionFrontendId": "178",
        "questionTitle": "Rank Scores",
        "translatedTitle": "分数排名",
        "questionTitleSlug": "rank-scores",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"66.1K\", \"totalSubmission\": \"113K\", \"totalAcceptedRaw\": 66099, \"totalSubmissionRaw\": 113004, \"acRate\": \"58.5%\"}",
        "translatedContent": "<p>编写一个 SQL 查询来实现分数排名。</p>\n\n<p>如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有&ldquo;间隔&rdquo;。</p>\n\n<pre>+----+-------+\n| Id | Score |\n+----+-------+\n| 1  | 3.50  |\n| 2  | 3.65  |\n| 3  | 4.00  |\n| 4  | 3.85  |\n| 5  | 4.00  |\n| 6  | 3.65  |\n+----+-------+\n</pre>\n\n<p>例如，根据上述给定的&nbsp;<code>Scores</code> 表，你的查询应该返回（按分数从高到低排列）：</p>\n\n<pre>+-------+------+\n| Score | Rank |\n+-------+------+\n| 4.00  | 1    |\n| 4.00  | 1    |\n| 3.85  | 2    |\n|&nbsp;3.65  | 3    |\n| 3.65  | 3    |\n| 3.50  | 4    |\n+-------+------+\n</pre>\n\n<p><strong>重要提示：</strong>对于 MySQL 解决方案，如果要转义用作列名的保留字，可以在关键字之前和之后使用撇号。例如 <strong>`Rank`</strong></p>\n",
        "topicTags": []
    },
    {
        "questionId": "179",
        "questionFrontendId": "179",
        "questionTitle": "Largest Number",
        "translatedTitle": "最大数",
        "questionTitleSlug": "largest-number",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"44.2K\", \"totalSubmission\": \"118.5K\", \"totalAcceptedRaw\": 44155, \"totalSubmissionRaw\": 118481, \"acRate\": \"37.3%\"}",
        "translatedContent": "<p>给定一组非负整数 <code>nums</code>，重新排列它们每位数字的顺序使之组成一个最大的整数。</p>\n\n<p><strong>注意：</strong>输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入<code>：</code></strong><code>nums = [10,2]</code>\n<strong>输出：</strong><code>&quot;210&quot;</code></pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre><strong>输入<code>：</code></strong><code>nums = [3,30,34,5,9]</code>\n<strong>输出：</strong><code>&quot;9534330&quot;</code>\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入<code>：</code></strong>nums = [1]\n<strong>输出：</strong>&quot;1&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入<code>：</code></strong>nums = [10]\n<strong>输出：</strong>&quot;10&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Sort",
                "slug": "sort"
            }
        ]
    },
    {
        "questionId": "180",
        "questionFrontendId": "180",
        "questionTitle": "Consecutive Numbers",
        "translatedTitle": "连续出现的数字",
        "questionTitleSlug": "consecutive-numbers",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"48.1K\", \"totalSubmission\": \"97.7K\", \"totalAcceptedRaw\": 48122, \"totalSubmissionRaw\": 97707, \"acRate\": \"49.3%\"}",
        "translatedContent": "<p>编写一个 SQL 查询，查找所有至少连续出现三次的数字。</p>\n\n<pre>+----+-----+\n| Id | Num |\n+----+-----+\n| 1  |  1  |\n| 2  |  1  |\n| 3  |  1  |\n| 4  |  2  |\n| 5  |  1  |\n| 6  |  2  |\n| 7  |  2  |\n+----+-----+\n</pre>\n\n<p>例如，给定上面的 <code>Logs</code> 表， <code>1</code> 是唯一连续出现至少三次的数字。</p>\n\n<pre>+-----------------+\n| ConsecutiveNums |\n+-----------------+\n| 1               |\n+-----------------+\n</pre>\n",
        "topicTags": []
    },
    {
        "questionId": "181",
        "questionFrontendId": "181",
        "questionTitle": "Employees Earning More Than Their Managers",
        "translatedTitle": "超过经理收入的员工",
        "questionTitleSlug": "employees-earning-more-than-their-managers",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"95.1K\", \"totalSubmission\": \"135.5K\", \"totalAcceptedRaw\": 95132, \"totalSubmissionRaw\": 135469, \"acRate\": \"70.2%\"}",
        "translatedContent": "<p><code>Employee</code>&nbsp;表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。</p>\n\n<pre>+----+-------+--------+-----------+\n| Id | Name  | Salary | ManagerId |\n+----+-------+--------+-----------+\n| 1  | Joe   | 70000  | 3         |\n| 2  | Henry | 80000  | 4         |\n| 3  | Sam   | 60000  | NULL      |\n| 4  | Max   | 90000  | NULL      |\n+----+-------+--------+-----------+\n</pre>\n\n<p>给定&nbsp;<code>Employee</code>&nbsp;表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。</p>\n\n<pre>+----------+\n| Employee |\n+----------+\n| Joe      |\n+----------+\n</pre>\n",
        "topicTags": []
    },
    {
        "questionId": "182",
        "questionFrontendId": "182",
        "questionTitle": "Duplicate Emails",
        "translatedTitle": "查找重复的电子邮箱",
        "questionTitleSlug": "duplicate-emails",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"111.4K\", \"totalSubmission\": \"140.1K\", \"totalAcceptedRaw\": 111437, \"totalSubmissionRaw\": 140116, \"acRate\": \"79.5%\"}",
        "translatedContent": "<p>编写一个 SQL 查询，查找&nbsp;<code>Person</code> 表中所有重复的电子邮箱。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>+----+---------+\n| Id | Email   |\n+----+---------+\n| 1  | a@b.com |\n| 2  | c@d.com |\n| 3  | a@b.com |\n+----+---------+\n</pre>\n\n<p>根据以上输入，你的查询应返回以下结果：</p>\n\n<pre>+---------+\n| Email   |\n+---------+\n| a@b.com |\n+---------+\n</pre>\n\n<p><strong>说明：</strong>所有电子邮箱都是小写字母。</p>\n",
        "topicTags": []
    },
    {
        "questionId": "183",
        "questionFrontendId": "183",
        "questionTitle": "Customers Who Never Order",
        "translatedTitle": "从不订购的客户",
        "questionTitleSlug": "customers-who-never-order",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"89.2K\", \"totalSubmission\": \"132.1K\", \"totalAcceptedRaw\": 89212, \"totalSubmissionRaw\": 132068, \"acRate\": \"67.6%\"}",
        "translatedContent": "<p>某网站包含两个表，<code>Customers</code> 表和 <code>Orders</code> 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。</p>\n\n<p><code>Customers</code> 表：</p>\n\n<pre>+----+-------+\n| Id | Name  |\n+----+-------+\n| 1  | Joe   |\n| 2  | Henry |\n| 3  | Sam   |\n| 4  | Max   |\n+----+-------+\n</pre>\n\n<p><code>Orders</code> 表：</p>\n\n<pre>+----+------------+\n| Id | CustomerId |\n+----+------------+\n| 1  | 3          |\n| 2  | 1          |\n+----+------------+\n</pre>\n\n<p>例如给定上述表格，你的查询应返回：</p>\n\n<pre>+-----------+\n| Customers |\n+-----------+\n| Henry     |\n| Max       |\n+-----------+\n</pre>\n",
        "topicTags": []
    },
    {
        "questionId": "184",
        "questionFrontendId": "184",
        "questionTitle": "Department Highest Salary",
        "translatedTitle": "部门工资最高的员工",
        "questionTitleSlug": "department-highest-salary",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"56.3K\", \"totalSubmission\": \"121.6K\", \"totalAcceptedRaw\": 56253, \"totalSubmissionRaw\": 121572, \"acRate\": \"46.3%\"}",
        "translatedContent": "<p><code>Employee</code> 表包含所有员工信息，每个员工有其对应的&nbsp;Id, salary 和 department Id。</p>\n\n<pre>+----+-------+--------+--------------+\n| Id | Name  | Salary | DepartmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 70000  | 1            |\n| 2 &nbsp;| Jim &nbsp; | 90000 &nbsp;| 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n| 3  | Henry | 80000  | 2            |\n| 4  | Sam   | 60000  | 2            |\n| 5  | Max   | 90000  | 1            |\n+----+-------+--------+--------------+</pre>\n\n<p><code>Department</code>&nbsp;表包含公司所有部门的信息。</p>\n\n<pre>+----+----------+\n| Id | Name     |\n+----+----------+\n| 1  | IT       |\n| 2  | Sales    |\n+----+----------+</pre>\n\n<p>编写一个 SQL 查询，找出每个部门工资最高的员工。对于上述表，您的 SQL 查询应返回以下行（行的顺序无关紧要）。</p>\n\n<pre>+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Max      | 90000  |\n| IT &nbsp; &nbsp; &nbsp; &nbsp; | Jim &nbsp; &nbsp; &nbsp;| 90000 &nbsp;|\n| Sales      | Henry    | 80000  |\n+------------+----------+--------+</pre>\n\n<p><strong>解释：</strong></p>\n\n<p>Max 和 Jim 在 IT 部门的工资都是最高的，Henry 在销售部的工资最高。</p>\n",
        "topicTags": []
    },
    {
        "questionId": "185",
        "questionFrontendId": "185",
        "questionTitle": "Department Top Three Salaries",
        "translatedTitle": "部门工资前三高的所有员工",
        "questionTitleSlug": "department-top-three-salaries",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"38.6K\", \"totalSubmission\": \"84.1K\", \"totalAcceptedRaw\": 38587, \"totalSubmissionRaw\": 84086, \"acRate\": \"45.9%\"}",
        "translatedContent": "<p><code>Employee</code> 表包含所有员工信息，每个员工有其对应的工号&nbsp;<code>Id</code>，姓名 <code>Name</code>，工资 <code>Salary</code> 和部门编号 <code>DepartmentId</code> 。</p>\n\n<pre>+----+-------+--------+--------------+\n| Id | Name  | Salary | DepartmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 85000  | 1            |\n| 2  | Henry | 80000  | 2            |\n| 3  | Sam   | 60000  | 2            |\n| 4  | Max   | 90000  | 1            |\n| 5  | Janet | 69000  | 1            |\n| 6  | Randy | 85000  | 1            |\n| 7  | Will  | 70000  | 1            |\n+----+-------+--------+--------------+</pre>\n\n<p><code>Department</code> 表包含公司所有部门的信息。</p>\n\n<pre>+----+----------+\n| Id | Name     |\n+----+----------+\n| 1  | IT       |\n| 2  | Sales    |\n+----+----------+</pre>\n\n<p>编写一个&nbsp;SQL 查询，找出每个部门获得前三高工资的所有员工。例如，根据上述给定的表，查询结果应返回：</p>\n\n<pre>+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Max      | 90000  |\n| IT         | Randy    | 85000  |\n| IT         | Joe      | 85000  |\n| IT         | Will     | 70000  |\n| Sales      | Henry    | 80000  |\n| Sales      | Sam      | 60000  |\n+------------+----------+--------+</pre>\n\n<p><strong>解释：</strong></p>\n\n<p>IT 部门中，Max 获得了最高的工资，Randy 和 Joe 都拿到了第二高的工资，Will 的工资排第三。销售部门（Sales）只有两名员工，Henry 的工资最高，Sam 的工资排第二。</p>\n",
        "topicTags": []
    },
    {
        "questionId": "186",
        "questionFrontendId": "186",
        "questionTitle": "Reverse Words in a String II",
        "translatedTitle": "翻转字符串里的单词 II",
        "questionTitleSlug": "reverse-words-in-a-string-ii",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"4.7K\", \"totalSubmission\": \"6.2K\", \"totalAcceptedRaw\": 4653, \"totalSubmissionRaw\": 6245, \"acRate\": \"74.5%\"}",
        "translatedContent": null,
        "topicTags": [
            {
                "name": "String",
                "slug": "string"
            }
        ]
    },
    {
        "questionId": "187",
        "questionFrontendId": "187",
        "questionTitle": "Repeated DNA Sequences",
        "translatedTitle": "重复的DNA序列",
        "questionTitleSlug": "repeated-dna-sequences",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"24.2K\", \"totalSubmission\": \"53.2K\", \"totalAcceptedRaw\": 24152, \"totalSubmissionRaw\": 53185, \"acRate\": \"45.4%\"}",
        "translatedContent": "<p>所有 DNA 都由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：&ldquo;ACGAATTCCG&rdquo;。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。</p>\n\n<p>编写一个函数来查找目标子串，目标子串的长度为 10，且在 DNA 字符串 <code>s</code> 中出现次数超过一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;\n<strong>输出：</strong>[&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;]</pre>\n",
        "topicTags": [
            {
                "name": "Bit Manipulation",
                "slug": "bit-manipulation"
            },
            {
                "name": "Hash Table",
                "slug": "hash-table"
            }
        ]
    },
    {
        "questionId": "188",
        "questionFrontendId": "188",
        "questionTitle": "Best Time to Buy and Sell Stock IV",
        "translatedTitle": "买卖股票的最佳时机 IV",
        "questionTitleSlug": "best-time-to-buy-and-sell-stock-iv",
        "difficulty": "Hard",
        "stats": "{\"totalAccepted\": \"34.1K\", \"totalSubmission\": \"111.5K\", \"totalAcceptedRaw\": 34109, \"totalSubmissionRaw\": 111544, \"acRate\": \"30.6%\"}",
        "translatedContent": "<p>给定一个整数数组 <code>prices</code> ，它的第<em> </em><code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code><em> </em>天的价格。</p>\n\n<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p>\n\n<p><strong>注意:</strong> 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 2, prices = [2,4,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 2, prices = [3,2,6,5,0,3]\n<strong>输出：</strong>7\n<strong>解释：</strong>在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。\n     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= k <= 10<sup>9</sup></code></li>\n\t<li><code>0 <= prices.length <= 10<sup>4</sup></code></li>\n\t<li><code>0 <= prices[i] <= 1000</code></li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "189",
        "questionFrontendId": "189",
        "questionTitle": "Rotate Array",
        "translatedTitle": "旋转数组",
        "questionTitleSlug": "rotate-array",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"172.4K\", \"totalSubmission\": \"398K\", \"totalAcceptedRaw\": 172365, \"totalSubmissionRaw\": 397968, \"acRate\": \"43.3%\"}",
        "translatedContent": "<p>给定一个数组，将数组中的元素向右移动&nbsp;<em>k&nbsp;</em>个位置，其中&nbsp;<em>k&nbsp;</em>是非负数。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> <code>[1,2,3,4,5,6,7]</code> 和 <em>k</em> = 3\n<strong>输出:</strong> <code>[5,6,7,1,2,3,4]</code>\n<strong>解释:</strong>\n向右旋转 1 步: <code>[7,1,2,3,4,5,6]</code>\n向右旋转 2 步: <code>[6,7,1,2,3,4,5]\n</code>向右旋转 3 步: <code>[5,6,7,1,2,3,4]</code>\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> <code>[-1,-100,3,99]</code> 和 <em>k</em> = 2\n<strong>输出:</strong> [3,99,-1,-100]\n<strong>解释:</strong> \n向右旋转 1 步: [99,-1,-100,3]\n向右旋转 2 步: [3,99,-1,-100]</pre>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li>\n\t<li>要求使用空间复杂度为&nbsp;O(1) 的&nbsp;<strong>原地&nbsp;</strong>算法。</li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Array",
                "slug": "array"
            }
        ]
    },
    {
        "questionId": "190",
        "questionFrontendId": "190",
        "questionTitle": "Reverse Bits",
        "translatedTitle": "颠倒二进制位",
        "questionTitleSlug": "reverse-bits",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"58.1K\", \"totalSubmission\": \"93.6K\", \"totalAcceptedRaw\": 58108, \"totalSubmissionRaw\": 93597, \"acRate\": \"62.1%\"}",
        "translatedContent": "<p>颠倒给定的 32 位无符号整数的二进制位。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入:</strong> 00000010100101000001111010011100\n<strong>输出:</strong> 00111001011110000010100101000000\n<strong>解释: </strong>输入的二进制串 <strong>00000010100101000001111010011100 </strong>表示无符号整数<strong> 43261596</strong><strong>，\n</strong>     因此返回 964176192，其二进制表示形式为 <strong>00111001011110000010100101000000</strong>。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>11111111111111111111111111111101\n<strong>输出：</strong>10111111111111111111111111111111\n<strong>解释：</strong>输入的二进制串 <strong>11111111111111111111111111111101</strong> 表示无符号整数 4294967293，\n&nbsp;    因此返回 3221225471 其二进制表示形式为 <strong>10111111111111111111111111111111 。</strong></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>\n\t<li>在 Java 中，编译器使用<a href=\"https://baike.baidu.com/item/二进制补码/5295284\" target=\"_blank\">二进制补码</a>记法来表示有符号整数。因此，在上面的&nbsp;<strong>示例 2</strong>&nbsp;中，输入表示有符号整数 <code>-3</code>，输出表示有符号整数 <code>-1073741825</code>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶</strong>:<br>\n如果多次调用这个函数，你将如何优化你的算法？</p>\n",
        "topicTags": [
            {
                "name": "Bit Manipulation",
                "slug": "bit-manipulation"
            }
        ]
    },
    {
        "questionId": "191",
        "questionFrontendId": "191",
        "questionTitle": "Number of 1 Bits",
        "translatedTitle": "位1的个数",
        "questionTitleSlug": "number-of-1-bits",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"89.4K\", \"totalSubmission\": \"127.6K\", \"totalAcceptedRaw\": 89407, \"totalSubmissionRaw\": 127617, \"acRate\": \"70.1%\"}",
        "translatedContent": "<p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 &lsquo;1&rsquo;&nbsp;的个数（也被称为<a href=\"https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F\" target=\"_blank\">汉明重量</a>）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>00000000000000000000000000001011\n<strong>输出：</strong>3\n<strong>解释：</strong>输入的二进制串 <code><strong>00000000000000000000000000001011</strong>&nbsp;中，共有三位为 &#39;1&#39;。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>00000000000000000000000010000000\n<strong>输出：</strong>1\n<strong>解释：</strong>输入的二进制串 <strong>00000000000000000000000010000000</strong>&nbsp;中，共有一位为 &#39;1&#39;。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>11111111111111111111111111111101\n<strong>输出：</strong>31\n<strong>解释：</strong>输入的二进制串 <strong>11111111111111111111111111111101</strong> 中，共有 31 位为 &#39;1&#39;。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>\n\t<li>在 Java 中，编译器使用<a href=\"https://baike.baidu.com/item/二进制补码/5295284\" target=\"_blank\">二进制补码</a>记法来表示有符号整数。因此，在上面的&nbsp;<strong>示例 3</strong>&nbsp;中，输入表示有符号整数 <code>-3</code>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶</strong>:<br>\n如果多次调用这个函数，你将如何优化你的算法？</p>\n",
        "topicTags": [
            {
                "name": "Bit Manipulation",
                "slug": "bit-manipulation"
            }
        ]
    },
    {
        "questionId": "192",
        "questionFrontendId": "192",
        "questionTitle": "Word Frequency",
        "translatedTitle": "统计词频",
        "questionTitleSlug": "word-frequency",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"14.1K\", \"totalSubmission\": \"40.5K\", \"totalAcceptedRaw\": 14084, \"totalSubmissionRaw\": 40506, \"acRate\": \"34.8%\"}",
        "translatedContent": "<p>写一个 bash 脚本以统计一个文本文件&nbsp;<code>words.txt</code>&nbsp;中每个单词出现的频率。</p>\n\n<p>为了简单起见，你可以假设：</p>\n\n<ul>\n\t<li><code>words.txt</code>只包括小写字母和&nbsp;<code>&#39; &#39;</code>&nbsp;。</li>\n\t<li>每个单词只由小写字母组成。</li>\n\t<li>单词间由一个或多个空格字符分隔。</li>\n</ul>\n\n<p><strong>示例:</strong></p>\n\n<p>假设 <code>words.txt</code> 内容如下：</p>\n\n<pre>the day is sunny the the\nthe sunny is is\n</pre>\n\n<p>你的脚本应当输出（以词频降序排列）：</p>\n\n<pre>the 4\nis 3\nsunny 2\nday 1\n</pre>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>不要担心词频相同的单词的排序问题，每个单词出现的频率都是唯一的。</li>\n\t<li>你可以使用一行&nbsp;<a href=\"http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-4.html\">Unix pipes</a>&nbsp;实现吗？</li>\n</ul>\n",
        "topicTags": []
    },
    {
        "questionId": "193",
        "questionFrontendId": "193",
        "questionTitle": "Valid Phone Numbers",
        "translatedTitle": "有效电话号码",
        "questionTitleSlug": "valid-phone-numbers",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"16.8K\", \"totalSubmission\": \"54.6K\", \"totalAcceptedRaw\": 16776, \"totalSubmissionRaw\": 54644, \"acRate\": \"30.7%\"}",
        "translatedContent": "<p>给定一个包含电话号码列表（一行一个电话号码）的文本文件 <code>file.txt</code>，写一个 bash 脚本输出所有有效的电话号码。</p>\n\n<p>你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或&nbsp;xxx-xxx-xxxx。（x 表示一个数字）</p>\n\n<p>你也可以假设每行前后没有多余的空格字符。</p>\n\n<p><strong>示例:</strong></p>\n\n<p>假设&nbsp;<code>file.txt</code>&nbsp;内容如下：</p>\n\n<pre>987-123-4567\n123 456 7890\n(123) 456-7890\n</pre>\n\n<p>你的脚本应当输出下列有效的电话号码：</p>\n\n<pre>987-123-4567\n(123) 456-7890\n</pre>\n",
        "topicTags": []
    },
    {
        "questionId": "194",
        "questionFrontendId": "194",
        "questionTitle": "Transpose File",
        "translatedTitle": "转置文件",
        "questionTitleSlug": "transpose-file",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"6.7K\", \"totalSubmission\": \"19.7K\", \"totalAcceptedRaw\": 6712, \"totalSubmissionRaw\": 19737, \"acRate\": \"34.0%\"}",
        "translatedContent": "<p>给定一个文件&nbsp;<code>file.txt</code>，转置它的内容。</p>\n\n<p>你可以假设每行列数相同，并且每个字段由&nbsp;<code>&#39; &#39;</code> 分隔.</p>\n\n<p><strong>示例:</strong></p>\n\n<p>假设&nbsp;<code>file.txt</code>&nbsp;文件内容如下：</p>\n\n<pre>name age\nalice 21\nryan 30\n</pre>\n\n<p>应当输出：</p>\n\n<pre>name alice ryan\nage 21 30\n</pre>\n",
        "topicTags": []
    },
    {
        "questionId": "195",
        "questionFrontendId": "195",
        "questionTitle": "Tenth Line",
        "translatedTitle": "第十行",
        "questionTitleSlug": "tenth-line",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"23.6K\", \"totalSubmission\": \"54.3K\", \"totalAcceptedRaw\": 23645, \"totalSubmissionRaw\": 54318, \"acRate\": \"43.5%\"}",
        "translatedContent": "<p>给定一个文本文件&nbsp;<code>file.txt</code>，请只打印这个文件中的第十行。</p>\n\n<p><strong>示例:</strong></p>\n\n<p>假设&nbsp;<code>file.txt</code> 有如下内容：</p>\n\n<pre>Line 1\nLine 2\nLine 3\nLine 4\nLine 5\nLine 6\nLine 7\nLine 8\nLine 9\nLine 10\n</pre>\n\n<p>你的脚本应当显示第十行：</p>\n\n<pre>Line 10\n</pre>\n\n<p><strong>说明:</strong><br>\n1. 如果文件少于十行，你应当输出什么？<br>\n2. 至少有三种不同的解法，请尝试尽可能多的方法来解题。</p>\n",
        "topicTags": []
    },
    {
        "questionId": "196",
        "questionFrontendId": "196",
        "questionTitle": "Delete Duplicate Emails",
        "translatedTitle": "删除重复的电子邮箱",
        "questionTitleSlug": "delete-duplicate-emails",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"58.7K\", \"totalSubmission\": \"91K\", \"totalAcceptedRaw\": 58669, \"totalSubmissionRaw\": 90995, \"acRate\": \"64.5%\"}",
        "translatedContent": "<p>编写一个 SQL 查询，来删除&nbsp;<code>Person</code>&nbsp;表中所有重复的电子邮箱，重复的邮箱里只保留&nbsp;<strong>Id&nbsp;</strong><em>最小&nbsp;</em>的那个。</p>\n\n<pre>+----+------------------+\n| Id | Email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n| 3  | john@example.com |\n+----+------------------+\nId 是这个表的主键。\n</pre>\n\n<p>例如，在运行你的查询语句之后，上面的 <code>Person</code> 表应返回以下几行:</p>\n\n<pre>+----+------------------+\n| Id | Email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n+----+------------------+\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>执行 SQL 之后，输出是整个 <code>Person</code>&nbsp;表。</li>\n\t<li>使用 <code>delete</code> 语句。</li>\n</ul>\n",
        "topicTags": []
    },
    {
        "questionId": "197",
        "questionFrontendId": "197",
        "questionTitle": "Rising Temperature",
        "translatedTitle": "上升的温度",
        "questionTitleSlug": "rising-temperature",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"54.7K\", \"totalSubmission\": \"104.2K\", \"totalAcceptedRaw\": 54664, \"totalSubmissionRaw\": 104153, \"acRate\": \"52.5%\"}",
        "translatedContent": "<div class=\"original__bRMd\">\n<div>\n<p>表 <code>Weather</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| recordDate    | date    |\n| temperature   | int     |\n+---------------+---------+\nid 是这个表的主键\n该表包含特定日期的温度信息</pre>\n\n<p> </p>\n\n<p>编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 <code>id</code> 。</p>\n\n<p>返回结果 <strong>不要求顺序</strong> 。</p>\n\n<p>查询结果格式如下例：</p>\n\n<pre>\n<code>Weather</code>\n+----+------------+-------------+\n| id | recordDate | Temperature |\n+----+------------+-------------+\n| 1  | 2015-01-01 | 10          |\n| 2  | 2015-01-02 | 25          |\n| 3  | 2015-01-03 | 20          |\n| 4  | 2015-01-04 | 30          |\n+----+------------+-------------+\n\nResult table:\n+----+\n| id |\n+----+\n| 2  |\n| 4  |\n+----+\n2015-01-02 的温度比前一天高（10 -> 25）\n2015-01-04 的温度比前一天高（30 -> 20）\n</pre>\n</div>\n</div>\n",
        "topicTags": []
    },
    {
        "questionId": "198",
        "questionFrontendId": "198",
        "questionTitle": "House Robber",
        "translatedTitle": "打家劫舍",
        "questionTitleSlug": "house-robber",
        "difficulty": "Easy",
        "stats": "{\"totalAccepted\": \"199.1K\", \"totalSubmission\": \"424.8K\", \"totalAcceptedRaw\": 199092, \"totalSubmissionRaw\": 424757, \"acRate\": \"46.9%\"}",
        "translatedContent": "<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>\n\n<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong> 不触动警报装置的情况下 </strong>，一夜之内能够偷窃到的最高金额。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[1,2,3,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n&nbsp;    偷窃到的最高金额 = 1 + 3 = 4 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>[2,7,9,3,1]\n<strong>输出：</strong>12\n<strong>解释：</strong>偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n&nbsp;    偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 400</code></li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Dynamic Programming",
                "slug": "dynamic-programming"
            }
        ]
    },
    {
        "questionId": "199",
        "questionFrontendId": "199",
        "questionTitle": "Binary Tree Right Side View",
        "translatedTitle": "二叉树的右视图",
        "questionTitleSlug": "binary-tree-right-side-view",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"70.6K\", \"totalSubmission\": \"109.6K\", \"totalAcceptedRaw\": 70568, \"totalSubmissionRaw\": 109601, \"acRate\": \"64.4%\"}",
        "translatedContent": "<p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong>&nbsp;[1,2,3,null,5,null,4]\n<strong>输出:</strong>&nbsp;[1, 3, 4]\n<strong>解释:\n</strong>\n   1            &lt;---\n /   \\\n2     3         &lt;---\n \\     \\\n  5     4       &lt;---\n</pre>\n",
        "topicTags": [
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            },
            {
                "name": "Breadth-first Search",
                "slug": "breadth-first-search"
            }
        ]
    },
    {
        "questionId": "200",
        "questionFrontendId": "200",
        "questionTitle": "Number of Islands",
        "translatedTitle": "岛屿数量",
        "questionTitleSlug": "number-of-islands",
        "difficulty": "Medium",
        "stats": "{\"totalAccepted\": \"168.8K\", \"totalSubmission\": \"333.7K\", \"totalAcceptedRaw\": 168770, \"totalSubmissionRaw\": 333707, \"acRate\": \"50.6%\"}",
        "translatedContent": "<p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>\n\n<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>\n\n<p>此外，你可以假设该网格的四条边均被水包围。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 <= m, n <= 300</code></li>\n\t<li><code>grid[i][j]</code> 的值为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "topicTags": [
            {
                "name": "Depth-first Search",
                "slug": "depth-first-search"
            },
            {
                "name": "Breadth-first Search",
                "slug": "breadth-first-search"
            },
            {
                "name": "Union Find",
                "slug": "union-find"
            }
        ]
    }

]
